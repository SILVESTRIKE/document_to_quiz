This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **node_modules/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/.dockerignore
backend/.env.example
backend/Dockerfile
backend/package.json
backend/src/app.ts
backend/src/config/db.config.ts
backend/src/config/swagger.config.ts
backend/src/config/token.config.ts
backend/src/controllers/admin.controller.ts
backend/src/controllers/auth.controller.ts
backend/src/controllers/feedback.controller.ts
backend/src/controllers/media.controller.ts
backend/src/controllers/product.controller.ts
backend/src/controllers/quiz.controller.ts
backend/src/controllers/user.controller.ts
backend/src/errors/CustomError.ts
backend/src/errors/index.ts
backend/src/middlewares/auth.middleware.ts
backend/src/middlewares/cors.middleware.ts
backend/src/middlewares/errorHandler.middleware.ts
backend/src/middlewares/quizUpload.middleware.ts
backend/src/middlewares/rateLimiter.middleware.ts
backend/src/middlewares/role.middleware.ts
backend/src/middlewares/upload.middleware.ts
backend/src/middlewares/validation.middleware.ts
backend/src/migrations/001-extract-questions.ts
backend/src/models/aiTrace.model.ts
backend/src/models/directory.model.ts
backend/src/models/feedback.model.ts
backend/src/models/globalQuestion.model.ts
backend/src/models/media.model.ts
backend/src/models/otp.model.ts
backend/src/models/plan.model.ts
backend/src/models/product.model.ts
backend/src/models/question.model.ts
backend/src/models/quiz.model.ts
backend/src/models/subscription.model.ts
backend/src/models/transaction.model.ts
backend/src/models/user.model.ts
backend/src/routes/admin.route.ts
backend/src/routes/auth.route.ts
backend/src/routes/feedback.route.ts
backend/src/routes/media.route.ts
backend/src/routes/product.route.ts
backend/src/routes/quiz.route.ts
backend/src/routes/user.route.ts
backend/src/routes/view.route.ts
backend/src/scripts/clearQueue.ts
backend/src/server.ts
backend/src/services/ai/aiOrchestrator.service.ts
backend/src/services/ai/providers/base.provider.ts
backend/src/services/ai/providers/gemini.provider.ts
backend/src/services/ai/providers/github.provider.ts
backend/src/services/ai/providers/groq.provider.ts
backend/src/services/ai/providers/huggingface.provider.ts
backend/src/services/ai/providers/index.ts
backend/src/services/auth.service.ts
backend/src/services/document.service.ts
backend/src/services/email.service.ts
backend/src/services/feedback.service.ts
backend/src/services/gemini.service.ts
backend/src/services/media.service.ts
backend/src/services/payment.service.ts
backend/src/services/quiz.service.ts
backend/src/types/ai.types.ts
backend/src/types/auth.types.ts
backend/src/types/feedback.types.ts
backend/src/types/global.types.ts
backend/src/types/index.ts
backend/src/types/product.types.ts
backend/src/types/quiz.types.ts
backend/src/types/zod/auth.schema.ts
backend/src/types/zod/common.schema.ts
backend/src/types/zod/feedback.schema.ts
backend/src/types/zod/index.ts
backend/src/types/zod/media.schema.ts
backend/src/types/zod/product.schema.ts
backend/src/utils/fileValidation.util.ts
backend/src/utils/fileValidator.util.ts
backend/src/utils/logger.util.ts
backend/src/utils/redis.util.ts
backend/src/utils/scheduler.util.ts
backend/src/utils/storage/drive.storage.ts
backend/src/utils/storage/index.ts
backend/src/utils/storage/local.storage.ts
backend/src/views/auth/login.ejs
backend/src/views/auth/register.ejs
backend/src/views/errors/404.ejs
backend/src/views/errors/500.ejs
backend/src/views/layouts/main.ejs
backend/src/views/pages/dashboard.ejs
backend/src/views/pages/home.ejs
backend/src/views/partials/auth.ejs
backend/src/views/partials/flash.ejs
backend/src/views/partials/footer.ejs
backend/src/views/partials/header.ejs
backend/src/views/quiz/detail.ejs
backend/src/views/quiz/practice.ejs
backend/src/views/quiz/processing.ejs
backend/src/views/quiz/upload.ejs
backend/src/workers/quiz.worker.ts
backend/test-parser.js
backend/tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# ===========================
# Dependencies
# ===========================
node_modules/
package-lock.json
yarn.lock
pnpm-lock.yaml
uploads/
# ===========================
# Environment & Secrets
# ===========================
.env
.env.local
.env.*.local
*.pem
*.key
credentials.json
service-account*.json

# ===========================
# Build & Output
# ===========================
dist/
build/
*.js.map
*.d.ts

# ===========================
# Uploads & User Data
# ===========================
uploads/
uploads/temp/
uploads/documents/
*.docx
*.pdf

# ===========================
# Logs
# ===========================
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ===========================
# IDE & Editor
# ===========================
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store
Thumbs.db

# ===========================
# Testing & Coverage
# ===========================
coverage/
.nyc_output/
*.lcov

# ===========================
# Debug & Temp Files
# ===========================
debug_*.json
*.tmp
*.temp
*.cache

# ===========================
# OS Generated
# ===========================
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
desktop.ini

# ===========================
# TypeScript
# ===========================
*.tsbuildinfo

# ===========================
# Redis & DB dumps
# ===========================
dump.rdb
*.rdb
</file>

<file path="backend/.dockerignore">
node_modules
npm-debug.log
dist
uploads
logs
.env
.env.local
*.log
.git
.gitignore
README.md
*.md
.vscode
.idea
coverage
.nyc_output
*.tsbuildinfo
</file>

<file path="backend/.env.example">
# Server
NODE_ENV=development
PORT=5000
BACKEND_URL=http://localhost:5000

# Database
MONGO_URI=mongodb://localhost:27017
DB_NAME=document_to_quiz_db

# JWT Authentication
JWT_SECRET=your-super-secret-key-change-in-production
JWT_REFRESH_SECRET=your-refresh-secret-key-change-in-production
JWT_ACCESS_EXPIRATION=900
JWT_REFRESH_EXPIRATION=2592000

# Redis (Upstash for production - free tier available)
REDIS_URL=redis://localhost:6379
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# Storage Mode: 'local' or 'cloud'
STORAGE_MODE=local

# Email (optional)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=
SMTP_PASS=
EMAIL_FROM=noreply@yourapp.com

# Frontend URL (for CORS)
FRONTEND_URL=http://localhost:3001

# Google Drive API
GOOGLE_DRIVE_CLIENT_EMAIL=
GOOGLE_DRIVE_PRIVATE_KEY=
GOOGLE_DRIVE_FOLDER_ID=

# ===========================
# AI Providers (5-Layer Fallback)
# ===========================

# Layer 1: Gemini (Primary) - Supports multiple keys for rotation
# Separate with commas: key1,key2,key3
GEMINI_API_KEYS=
GEMINI_API_KEY=

# Layer 2: GitHub Models (gpt-4o-mini, Llama-3.1-70B)
GITHUB_TOKEN=
GITHUB_MODEL=gpt-4o-mini

# Layer 3: Groq Cloud (Llama 3.1 70B - ultra fast)
GROQ_API_KEY=

# Layer 4: Hugging Face (Qwen2.5-72B)
HF_ACCESS_TOKEN=

# ===========================
# BullMQ Configuration
# ===========================
BULLMQ_QUIZ_CONCURRENCY=1
</file>

<file path="backend/Dockerfile">
# ================================
# Build Stage
# ================================
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install ALL dependencies (including devDependencies for TypeScript build)
RUN npm ci

# Copy source code
COPY . .

# Build TypeScript
RUN npm run build

# ================================
# Production Stage
# ================================
FROM node:20-alpine AS runner

WORKDIR /app

# Copy package files and install production only
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Copy built files from builder
COPY --from=builder /app/dist ./dist

# Copy views (EJS templates)
COPY --from=builder /app/src/views ./dist/views

# Create uploads directory
RUN mkdir -p uploads/temp uploads/documents

# Create non-root user for security
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 expressjs

# Change ownership of uploads directory
RUN chown -R expressjs:nodejs uploads

USER expressjs

# Environment
ENV NODE_ENV=production
ENV PORT=5000

EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:5000/health || exit 1

CMD ["node", "dist/server.js"]
</file>

<file path="backend/package.json">
{
    "name": "document-to-quiz",
    "version": "1.0.0",
    "description": "Document to Quiz conversion system with AI answer detection",
    "main": "dist/server.js",
    "scripts": {
        "build": "tsc",
        "start": "node dist/server.js",
        "dev": "ts-node-dev --respawn --transpile-only src/server.ts"
    },
    "dependencies": {
        "@google/generative-ai": "0.21.0",
        "@huggingface/inference": "4.13.5",
        "@types/lodash": "4.17.21",
        "bcryptjs": "^2.4.3",
        "bullmq": "^5.34.8",
        "compression": "^1.8.1",
        "cookie-parser": "^1.4.7",
        "cors": "^2.8.5",
        "docx": "9.5.1",
        "dotenv": "^16.5.0",
        "ejs": "3.1.10",
        "express": "^4.19.2",
        "express-ejs-layouts": "2.5.1",
        "express-rate-limit": "^8.1.0",
        "express-ws": "^5.0.2",
        "file-type": "16.5.4",
        "googleapis": "^144.0.0",
        "helmet": "^8.1.0",
        "jsonwebtoken": "^9.0.2",
        "lodash": "4.17.21",
        "mammoth": "^1.8.0",
        "mongoose": "^8.16.0",
        "multer": "^1.4.5-lts.1",
        "node-cron": "^3.0.3",
        "nodemailer": "^7.0.9",
        "pdf-parse": "^1.1.1",
        "pdfjs-dist": "3.11.174",
        "rate-limit-redis": "^4.2.2",
        "redis": "^5.8.3",
        "swagger-jsdoc": "^6.2.8",
        "swagger-ui-express": "^5.0.1",
        "uuid": "^11.1.0",
        "winston": "^3.18.3",
        "ws": "^8.18.3",
        "zod": "^3.25.76"
    },
    "devDependencies": {
        "@types/bcryptjs": "^2.4.6",
        "@types/compression": "^1.8.1",
        "@types/cookie-parser": "^1.4.7",
        "@types/cors": "^2.8.19",
        "@types/express": "^4.17.21",
        "@types/express-ejs-layouts": "2.5.4",
        "@types/express-ws": "^3.0.6",
        "@types/jsonwebtoken": "^9.0.6",
        "@types/multer": "^1.4.11",
        "@types/node": "^20.19.25",
        "@types/node-cron": "^3.0.11",
        "@types/nodemailer": "^6.4.15",
        "@types/swagger-jsdoc": "^6.0.4",
        "@types/swagger-ui-express": "^4.1.6",
        "@types/uuid": "^10.0.0",
        "@types/ws": "^8.18.1",
        "ts-node-dev": "^2.0.0",
        "typescript": "^5.5.2"
    }
}
</file>

<file path="backend/src/app.ts">
/**
 * App Configuration
 * Main Express application setup with all middleware and routes.
 */
import dotenv from "dotenv";
dotenv.config();

import express from "express";
import path from "path";
import cookieParser from "cookie-parser";
import compression from "compression";
import helmet from "helmet";
import expressLayouts from "express-ejs-layouts";

import { errorHandlerMiddleware } from "./middlewares/errorHandler.middleware";
import { corsMiddleware } from "./middlewares/cors.middleware";
import { apiLimiter } from "./middlewares/rateLimiter.middleware";
import "./utils/redis.util";
import { startSchedulers } from "./utils/scheduler.util";

// Import routes
import authRoutes from "./routes/auth.route";
import userRoutes from "./routes/user.route";
import productRoutes from "./routes/product.route";
import mediaRoutes from "./routes/media.route";
import feedbackRoutes from "./routes/feedback.route";
import adminRoutes from "./routes/admin.route";
import quizRoutes from "./routes/quiz.route";
import viewRoutes from "./routes/view.route";
import { startQuizWorker } from "./workers/quiz.worker";

// Swagger
import swaggerUi from "swagger-ui-express";
import swaggerJSDoc from "swagger-jsdoc";
import { swaggerOptions } from "./config/swagger.config";

const swaggerSpec = swaggerJSDoc(swaggerOptions);
const app = express();

// Trust proxy for rate limiting behind reverse proxy
app.set("trust proxy", 1);

// ===== EJS View Engine Setup =====
app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));
app.use(expressLayouts);
app.set("layout", "layouts/main");

// ===== Security & Performance Middleware =====
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'", "https://cdn.tailwindcss.com"],
            scriptSrcAttr: ["'unsafe-inline'"], // Allow inline onclick handlers
            styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
            fontSrc: ["'self'", "https://fonts.gstatic.com"],
            imgSrc: ["'self'", "data:", "https:"],
            connectSrc: ["'self'"],
        },
    },
})); // Security headers with CSP for TailwindCSS
app.use(compression()); // Gzip compression
app.use(corsMiddleware);
app.use(express.json({ limit: "50mb" }));
app.use(express.urlencoded({ extended: true, limit: "50mb" }));
app.use(cookieParser());

// ===== Static Files =====
const uploadsDir = path.join(__dirname, "..", "uploads");
app.use("/uploads", express.static(uploadsDir));

// ===== Swagger API Documentation =====
if (process.env.NODE_ENV !== "production") {
    app.get("/api-docs.json", (req, res) => {
        res.setHeader("Content-Type", "application/json");
        res.send(swaggerSpec);
    });

    app.use(
        "/api-docs",
        swaggerUi.serve,
        swaggerUi.setup(undefined, {
            swaggerUrl: "/api-docs.json",
            swaggerOptions: { tryItOutEnabled: true },
        })
    );
} else {
    app.use("/api-docs", (req, res) => {
        res.status(404).json({ message: "Not found" });
    });
}

// ===== Health Check =====
app.get("/health", (req, res) => {
    res.json({
        status: "ok",
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV || "development",
        storageMode: process.env.STORAGE_MODE || "local",
    });
});

// ===== Rate Limiting =====
app.use(apiLimiter);

// ===== API Routes =====
app.use("/api/auth", authRoutes);
app.use("/api/users", userRoutes);
app.use("/api/products", productRoutes);
app.use("/api/media", mediaRoutes);
app.use("/api/feedback", feedbackRoutes);
app.use("/api/admin", adminRoutes);
app.use("/api/v1/quizzes", quizRoutes);

// ===== View Routes (EJS Pages) =====
app.use("/", viewRoutes);

// ===== 404 Handler for non-API routes =====
app.use((req, res, next) => {
    if (req.path.startsWith("/api")) {
        res.status(404).json({ error: "Not found" });
    } else {
        res.status(404).render("errors/404", {
            title: "Không tìm thấy",
            user: null,
            flash: null
        });
    }
});

// ===== Error Handler (must be last) =====
app.use(errorHandlerMiddleware);

// ===== Start Scheduled Tasks =====
startSchedulers();

// ===== Start Quiz Worker =====
startQuizWorker();

export default app;
</file>

<file path="backend/src/config/db.config.ts">
/**
 * Database Configuration
 */
import mongoose from "mongoose";
import { logger } from "../utils/logger.util";

export async function connectDB(): Promise<void> {
    const mongoUri = process.env.MONGO_URI || "mongodb://localhost:27017";
    const dbName = process.env.DB_NAME || "monolith_db";

    try {
        await mongoose.connect(`${mongoUri}/${dbName}`);
        logger.info(`[MongoDB] Connected to ${dbName}`);
    } catch (error) {
        logger.error("[MongoDB] Connection failed:", error);
        throw error;
    }
}

export async function closeDB(): Promise<void> {
    await mongoose.connection.close();
    logger.info("[MongoDB] Connection closed");
}
</file>

<file path="backend/src/config/swagger.config.ts">
/**
 * Swagger Configuration
 */
export const swaggerOptions = {
    definition: {
        openapi: "3.0.0",
        info: {
            title: "Monolith Template API",
            version: "1.0.0",
            description: "API documentation for the monolith template",
        },
        servers: [
            {
                url: process.env.API_URL || "http://localhost:5000",
                description: "Development server",
            },
        ],
        components: {
            securitySchemes: {
                bearerAuth: {
                    type: "http",
                    scheme: "bearer",
                    bearerFormat: "JWT",
                },
            },
        },
        security: [{ bearerAuth: [] }],
    },
    apis: ["./src/routes/*.ts", "./src/controllers/*.ts"],
};
</file>

<file path="backend/src/config/token.config.ts">
/**
 * Token Configuration
 */
export const tokenConfig = {
    access: {
        secret: process.env.JWT_SECRET || "your-access-secret",
        expirationSeconds: parseInt(process.env.JWT_ACCESS_EXPIRATION || "900", 10),
    },
    refresh: {
        secret: process.env.JWT_REFRESH_SECRET || "your-refresh-secret",
        expirationSeconds: parseInt(process.env.JWT_REFRESH_EXPIRATION || "2592000", 10),
    },
};

export const refreshTokenCookieConfig = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax" as const,
    path: "/",
    maxAge: tokenConfig.refresh.expirationSeconds * 1000,
};
</file>

<file path="backend/src/controllers/admin.controller.ts">
/**
 * Admin Controller
 * Handles HTTP request/response for admin endpoints.
 */
import { Request, Response, NextFunction } from "express";
import User from "../models/user.model";
import Product from "../models/product.model";
import { NotFoundError } from "../errors";

export const adminController = {
    async getDashboard(req: Request, res: Response, next: NextFunction) {
        try {
            const [totalUsers, totalProducts] = await Promise.all([
                User.countDocuments(),
                Product.countDocuments(),
            ]);

            const startOfMonth = new Date();
            startOfMonth.setDate(1);
            startOfMonth.setHours(0, 0, 0, 0);

            const newUsersThisMonth = await User.countDocuments({ createdAt: { $gte: startOfMonth } });

            res.json({
                success: true,
                data: {
                    users: { total: totalUsers, newThisMonth: newUsersThisMonth },
                    products: { total: totalProducts },
                },
            });
        } catch (error) {
            next(error);
        }
    },

    async listUsers(req: Request, res: Response, next: NextFunction) {
        try {
            const { page = 1, limit = 20, search, role } = req.query;
            const filter: any = {};
            if (search) {
                filter.$or = [
                    { username: new RegExp(search as string, "i") },
                    { email: new RegExp(search as string, "i") },
                ];
            }
            if (role) filter.role = role;

            const [total, users] = await Promise.all([
                User.countDocuments(filter),
                User.find(filter)
                    .sort({ createdAt: -1 })
                    .skip((+page - 1) * +limit)
                    .limit(+limit),
            ]);

            res.json({
                success: true,
                data: users,
                pagination: { total, page: +page, limit: +limit, pages: Math.ceil(total / +limit) },
            });
        } catch (error) {
            next(error);
        }
    },

    async updateUserRole(req: Request, res: Response, next: NextFunction) {
        try {
            const { role } = req.body;
            const user = await User.findByIdAndUpdate(req.params.id, { role }, { new: true });
            if (!user) throw new NotFoundError("User not found");
            res.json({ success: true, data: user });
        } catch (error) {
            next(error);
        }
    },

    async updateUserStatus(req: Request, res: Response, next: NextFunction) {
        try {
            const { isActive } = req.body;
            const user = await User.findByIdAndUpdate(req.params.id, { isActive }, { new: true });
            if (!user) throw new NotFoundError("User not found");
            res.json({ success: true, data: user });
        } catch (error) {
            next(error);
        }
    },
};
</file>

<file path="backend/src/controllers/auth.controller.ts">
/**
 * Auth Controller
 * Handles HTTP request/response for authentication endpoints.
 */
import { Request, Response, NextFunction } from "express";
import { authService } from "../services/auth.service";
import { refreshTokenCookieConfig } from "../config/token.config";

export const authController = {
    async register(req: Request, res: Response, next: NextFunction) {
        try {
            const result = await authService.register(req.body);
            res.status(201).json({ success: true, ...result });
        } catch (error) {
            next(error);
        }
    },

    async login(req: Request, res: Response, next: NextFunction) {
        try {
            const { email, password } = req.body;
            const result = await authService.login(email, password);
            res.cookie("refreshToken", result.tokens.refreshToken, refreshTokenCookieConfig);
            res.json({ success: true, ...result });
        } catch (error) {
            next(error);
        }
    },

    async logout(req: Request, res: Response, next: NextFunction) {
        try {
            const refreshToken = req.cookies.refreshToken || req.body.refreshToken;
            await authService.logout(refreshToken);
            res.clearCookie("refreshToken", { path: refreshTokenCookieConfig.path });
            res.json({ success: true, message: "Logged out" });
        } catch (error) {
            next(error);
        }
    },

    async refreshToken(req: Request, res: Response, next: NextFunction) {
        try {
            const token = req.cookies.refreshToken || req.body.refreshToken;
            console.log("[Auth] Refresh attempt - Cookie refreshToken:", req.cookies.refreshToken ? "present" : "missing");
            console.log("[Auth] Refresh attempt - Body refreshToken:", req.body.refreshToken ? "present" : "missing");
            console.log("[Auth] All cookies:", Object.keys(req.cookies));

            const result = await authService.refreshToken(token);
            console.log("[Auth] Refresh SUCCESS - Setting new cookie and returning tokens");
            res.cookie("refreshToken", result.refreshToken, refreshTokenCookieConfig);
            res.json({ success: true, tokens: result });
        } catch (error) {
            console.log("[Auth] Refresh failed:", error);
            next(error);
        }
    },
};
</file>

<file path="backend/src/controllers/feedback.controller.ts">
/**
 * Feedback Controller
 * Handles HTTP request/response for feedback endpoints.
 */
import { Request, Response, NextFunction } from "express";
import { feedbackService } from "../services/feedback.service";

export const feedbackController = {
    async getByReference(req: Request, res: Response, next: NextFunction) {
        try {
            const { page, limit, status } = req.query;
            const result = await feedbackService.findByReference(req.params.id, req.params.type, {
                page: page ? +page : undefined,
                limit: limit ? +limit : undefined,
                status: status as any,
            });
            res.json({ success: true, ...result });
        } catch (error) {
            next(error);
        }
    },

    async getAverageRating(req: Request, res: Response, next: NextFunction) {
        try {
            const result = await feedbackService.getAverageRating(req.params.id, req.params.type);
            res.json({ success: true, data: result });
        } catch (error) {
            next(error);
        }
    },

    async create(req: Request, res: Response, next: NextFunction) {
        try {
            const feedback = await feedbackService.create({ userId: req.user!.id, ...req.body });
            res.status(201).json({ success: true, data: feedback });
        } catch (error) {
            next(error);
        }
    },

    async getMyFeedbacks(req: Request, res: Response, next: NextFunction) {
        try {
            const { page, limit } = req.query;
            const result = await feedbackService.findByUser(req.user!.id, {
                page: page ? +page : undefined,
                limit: limit ? +limit : undefined,
            });
            res.json({ success: true, ...result });
        } catch (error) {
            next(error);
        }
    },

    async update(req: Request, res: Response, next: NextFunction) {
        try {
            const feedback = await feedbackService.update(req.params.id, req.user!.id, req.body);
            res.json({ success: true, data: feedback });
        } catch (error) {
            next(error);
        }
    },

    async delete(req: Request, res: Response, next: NextFunction) {
        try {
            await feedbackService.delete(req.params.id, req.user!.id);
            res.json({ success: true, message: "Feedback deleted" });
        } catch (error) {
            next(error);
        }
    },

    async approve(req: Request, res: Response, next: NextFunction) {
        try {
            const feedback = await feedbackService.approve(req.params.id, req.user!.id, req.body.notes);
            res.json({ success: true, data: feedback });
        } catch (error) {
            next(error);
        }
    },

    async reject(req: Request, res: Response, next: NextFunction) {
        try {
            const feedback = await feedbackService.reject(req.params.id, req.user!.id, req.body.reason);
            res.json({ success: true, data: feedback });
        } catch (error) {
            next(error);
        }
    },
};
</file>

<file path="backend/src/controllers/media.controller.ts">
/**
 * Media Controller
 * Handles HTTP request/response for media endpoints.
 */
import { Request, Response, NextFunction } from "express";
import { mediaService } from "../services/media.service";
import { storageService } from "../utils/storage";
import { cleanupTempFile } from "../middlewares/upload.middleware";
import { BadRequestError, NotFoundError } from "../errors";

export const mediaController = {
    async uploadSingle(req: Request, res: Response, next: NextFunction) {
        try {
            if (!req.file) throw new BadRequestError("No file provided");

            const { directoryId } = req.body;
            const folder = directoryId ? `uploads/${directoryId}` : "uploads";

            const media = await mediaService.uploadAndCreate(req.file, folder, req.user!.id, directoryId);
            res.status(201).json({
                success: true,
                data: { ...media.toObject(), url: storageService.getUrl(media.mediaPath) },
            });
        } catch (error) {
            if (req.file?.path) cleanupTempFile(req.file.path);
            next(error);
        }
    },

    async uploadMultiple(req: Request, res: Response, next: NextFunction) {
        try {
            if (!req.files || !Array.isArray(req.files) || req.files.length === 0) {
                throw new BadRequestError("No files provided");
            }

            const { directoryId } = req.body;
            const folder = directoryId ? `uploads/${directoryId}` : "uploads";
            const results = [];

            for (const file of req.files) {
                const media = await mediaService.uploadAndCreate(file, folder, req.user!.id, directoryId);
                results.push({ ...media.toObject(), url: storageService.getUrl(media.mediaPath) });
            }

            res.status(201).json({ success: true, data: results });
        } catch (error) {
            if (req.files && Array.isArray(req.files)) {
                req.files.forEach(function (file) {
                    cleanupTempFile(file.path);
                });
            }
            next(error);
        }
    },

    async list(req: Request, res: Response, next: NextFunction) {
        try {
            const { page, limit, search, type, directoryId } = req.query;
            const result = await mediaService.findAndPaginate({
                page: page ? +page : undefined,
                limit: limit ? +limit : undefined,
                search: search as string,
                type: type as string,
                directoryId: directoryId as string,
                uploader: req.user!.id,
            });

            const dataWithUrls = result.data.map(function (m) {
                return {
                    ...m.toObject(),
                    url: storageService.getUrl(m.mediaPath),
                };
            });

            res.json({ success: true, data: dataWithUrls, pagination: result.pagination });
        } catch (error) {
            next(error);
        }
    },

    async getById(req: Request, res: Response, next: NextFunction) {
        try {
            const media = await mediaService.findById(req.params.id);
            if (!media) throw new NotFoundError("Media not found");
            res.json({ success: true, data: { ...media.toObject(), url: storageService.getUrl(media.mediaPath) } });
        } catch (error) {
            next(error);
        }
    },

    async update(req: Request, res: Response, next: NextFunction) {
        try {
            const { name, tags } = req.body;
            const media = await mediaService.update(req.params.id, { name, tags });
            if (!media) throw new NotFoundError("Media not found");
            res.json({ success: true, data: media });
        } catch (error) {
            next(error);
        }
    },

    async delete(req: Request, res: Response, next: NextFunction) {
        try {
            const { force } = req.query;
            if (force === "true") {
                const deleted = await mediaService.hardDelete(req.params.id);
                if (!deleted) throw new NotFoundError("Media not found");
                res.json({ success: true, message: "Media permanently deleted" });
            } else {
                const media = await mediaService.softDelete(req.params.id);
                if (!media) throw new NotFoundError("Media not found");
                res.json({ success: true, message: "Media deleted" });
            }
        } catch (error) {
            next(error);
        }
    },
};
</file>

<file path="backend/src/controllers/product.controller.ts">
/**
 * Product Controller
 * Handles HTTP request/response for product endpoints.
 */
import { Request, Response, NextFunction } from "express";
import Product from "../models/product.model";
import { NotFoundError, ForbiddenError } from "../errors";

export const productController = {
    async list(req: Request, res: Response, next: NextFunction) {
        try {
            const { page = 1, limit = 20, search, category } = req.query;
            const filter: any = { isActive: true };
            if (search) filter.$text = { $search: search as string };
            if (category) filter.category = category;

            const [total, products] = await Promise.all([
                Product.countDocuments(filter),
                Product.find(filter)
                    .sort({ createdAt: -1 })
                    .skip((+page - 1) * +limit)
                    .limit(+limit)
                    .populate("owner", "username"),
            ]);

            res.json({
                success: true,
                data: products,
                pagination: { total, page: +page, limit: +limit, pages: Math.ceil(total / +limit) },
            });
        } catch (error) {
            next(error);
        }
    },

    async getById(req: Request, res: Response, next: NextFunction) {
        try {
            const product = await Product.findById(req.params.id).populate("owner", "username");
            if (!product) throw new NotFoundError("Product not found");
            res.json({ success: true, data: product });
        } catch (error) {
            next(error);
        }
    },

    async create(req: Request, res: Response, next: NextFunction) {
        try {
            const product = await Product.create({ ...req.body, owner: req.user!.id });
            res.status(201).json({ success: true, data: product });
        } catch (error) {
            next(error);
        }
    },

    async update(req: Request, res: Response, next: NextFunction) {
        try {
            const product = await Product.findById(req.params.id);
            if (!product) throw new NotFoundError("Product not found");
            if (product.owner.toString() !== req.user!.id && req.user!.role !== "admin") {
                throw new ForbiddenError("Not authorized to edit this product");
            }

            Object.assign(product, req.body);
            await product.save();
            res.json({ success: true, data: product });
        } catch (error) {
            next(error);
        }
    },

    async delete(req: Request, res: Response, next: NextFunction) {
        try {
            const product = await Product.findById(req.params.id);
            if (!product) throw new NotFoundError("Product not found");
            if (product.owner.toString() !== req.user!.id && req.user!.role !== "admin") {
                throw new ForbiddenError("Not authorized to delete this product");
            }

            await product.deleteOne();
            res.json({ success: true, message: "Product deleted" });
        } catch (error) {
            next(error);
        }
    },
};
</file>

<file path="backend/src/controllers/quiz.controller.ts">
/**
 * Quiz Controller
 * Handles HTTP request/response and error catching for quiz endpoints.
 */
import { Request, Response, NextFunction } from "express";
import path from "path";
import fs from "fs";
import { quizService } from "../services/quiz.service";
import { updateQuestionSchema, quizQuerySchema } from "../types/quiz.types";
import { AnswerSource } from "../models/quiz.model";
import { validateFileMagicBytes, isDangerousFileType } from "../utils/fileValidator.util";

export const quizController = {
    /**
     * Upload document to create quiz
     */
    async uploadQuiz(req: Request, res: Response, next: NextFunction) {
        try {
            if (!req.file) {
                res.status(400).json({ error: "No file uploaded" });
                return;
            }

            // Validate magic bytes to prevent malicious file uploads
            const validation = validateFileMagicBytes(req.file.path, req.file.mimetype);
            if (!validation.isValid) {
                // Delete the suspicious file
                if (fs.existsSync(req.file.path)) {
                    fs.unlinkSync(req.file.path);
                }

                // Check for dangerous file types
                if (isDangerousFileType(validation.detectedType)) {
                    res.status(400).json({
                        error: "Potentially dangerous file detected. Upload rejected.",
                        code: "DANGEROUS_FILE"
                    });
                    return;
                }

                res.status(400).json({
                    error: validation.error || "Invalid file type",
                    code: "INVALID_FILE_TYPE"
                });
                return;
            }

            const quiz = await quizService.createFromUpload({
                file: req.file,
                title: req.body.title,
                userId: req.user!.id,
            });

            // Check if this is a duplicate redirect
            const quizAny = quiz as any;
            if (quizAny.isDuplicate) {
                res.status(200).json({
                    isDuplicate: true,
                    existingQuizId: quizAny.existingQuizId,
                    message: "File này đã được upload trước đó. Đang chuyển đến bài quiz hiện có.",
                });
                return;
            }

            res.status(201).json({
                quizId: quiz._id.toString(),
                message: "Document uploaded. Processing started.",
                status: quiz.status,
            });
        } catch (error) {
            next(error);
        }
    },

    /**
     * Get quiz processing status
     */
    async getQuizStatus(req: Request, res: Response, next: NextFunction) {
        try {
            const status = await quizService.getStatus(req.params.id);
            res.json(status);
        } catch (error) {
            next(error);
        }
    },

    /**
     * Get full quiz with questions
     */
    async getQuiz(req: Request, res: Response, next: NextFunction) {
        try {
            const quiz = await quizService.findById(req.params.id);
            if (!quiz) {
                res.status(404).json({ error: "Quiz not found" });
                return;
            }

            res.json({
                id: quiz._id.toString(),
                title: quiz.title,
                documentUrl: quiz.documentUrl,
                documentType: quiz.documentType,
                status: quiz.status,
                questions: quiz.questions.map(function (q) {
                    return {
                        id: q._id?.toString(),
                        stem: q.stem,
                        choices: q.choices,
                        correctAnswerKey: q.correctAnswerKey,
                        explanation: q.explanation,
                        source: q.source,
                        section: q.section || "", // Include section for filtering
                    };
                }),
                totalQuestions: quiz.totalQuestions,
                processedQuestions: quiz.processedQuestions,
                debugJsonPath: quiz.debugJsonPath,
                createdAt: quiz.createdAt.toISOString(),
                updatedAt: quiz.updatedAt.toISOString(),
            });
        } catch (error) {
            next(error);
        }
    },

    /**
     * List quizzes with pagination
     * Always shows all quizzes (public)
     */
    async listQuizzes(req: Request, res: Response, next: NextFunction) {
        try {
            const query = quizQuerySchema.parse(req.query);
            const result = await quizService.findAndPaginate(query);

            res.json(result);
        } catch (error) {
            next(error);
        }
    },

    /**
     * Update a specific question
     */
    async updateQuestion(req: Request, res: Response, next: NextFunction) {
        try {
            const data = updateQuestionSchema.parse(req.body);
            data.source = AnswerSource.Manual;

            const quiz = await quizService.updateQuestion(
                req.params.id,
                req.params.qid,
                data
            );

            if (!quiz) {
                res.status(404).json({ error: "Quiz or question not found" });
                return;
            }

            res.json({ message: "Question updated successfully" });
        } catch (error) {
            next(error);
        }
    },

    /**
     * Delete a quiz (owner only)
     */
    async deleteQuiz(req: Request, res: Response, next: NextFunction) {
        try {
            // First find the quiz to check ownership
            const quiz = await quizService.findById(req.params.id);
            if (!quiz) {
                res.status(404).json({ error: "Quiz not found" });
                return;
            }

            // Check ownership - only creator can delete
            if (quiz.createdBy.toString() !== req.user!.id) {
                res.status(403).json({ error: "Unauthorized - bạn không phải chủ sở hữu quiz này" });
                return;
            }

            // Now safe to delete
            await quizService.softDelete(req.params.id);
            res.json({ message: "Quiz deleted successfully" });
        } catch (error) {
            next(error);
        }
    },

    /**
     * Debug endpoint - Parse file and return raw JSON
     */
    async debugParse(req: Request, res: Response, next: NextFunction) {
        try {
            if (!req.file) {
                res.status(400).json({ error: "No file uploaded" });
                return;
            }

            const result = await quizService.debugParseFile(req.file);
            res.json(result);
        } catch (error) {
            next(error);
        }
    },

    /**
     * Get AI explanation when user answers incorrectly
     */
    async explainWrongAnswer(req: Request, res: Response, next: NextFunction) {
        try {
            const { userAnswerKey } = req.body;

            if (!userAnswerKey) {
                res.status(400).json({ error: "userAnswerKey is required" });
                return;
            }

            const result = await quizService.explainWrongAnswer(
                req.params.id,
                req.params.qid,
                userAnswerKey
            );

            res.json(result);
        } catch (error) {
            next(error);
        }
    },

    /**
     * Download quiz as DOCX with highlighted correct answers
     */
    async downloadHighlightedDoc(req: Request, res: Response, next: NextFunction) {
        try {
            const { documentService } = await import("../services/document.service");

            const quiz = await quizService.findById(req.params.id);
            if (!quiz) {
                res.status(404).json({ error: "Quiz not found" });
                return;
            }

            if (quiz.status !== "completed") {
                res.status(400).json({ error: "Quiz is not yet completed" });
                return;
            }

            const buffer = await documentService.generateHighlightedDocx(quiz);
            const fileName = `${quiz.title || "quiz"}_answers.docx`;

            res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
            res.setHeader("Content-Disposition", `attachment; filename="${encodeURIComponent(fileName)}"`);
            res.send(buffer);
        } catch (error) {
            next(error);
        }
    },
};
</file>

<file path="backend/src/controllers/user.controller.ts">
/**
 * User Controller
 * Handles HTTP request/response for user endpoints.
 */
import { Request, Response, NextFunction } from "express";
import User from "../models/user.model";
import { NotFoundError } from "../errors";

export const userController = {
    async getMe(req: Request, res: Response, next: NextFunction) {
        try {
            const user = await User.findById(req.user!.id);
            if (!user) throw new NotFoundError("User not found");
            res.json({ success: true, data: user });
        } catch (error) {
            next(error);
        }
    },

    async updateMe(req: Request, res: Response, next: NextFunction) {
        try {
            const { fullName, avatarUrl } = req.body;
            const user = await User.findByIdAndUpdate(
                req.user!.id,
                { fullName, avatarUrl },
                { new: true }
            );
            if (!user) throw new NotFoundError("User not found");
            res.json({ success: true, data: user });
        } catch (error) {
            next(error);
        }
    },
};
</file>

<file path="backend/src/errors/CustomError.ts">
/**
 * Custom Error Base Class
 */
export abstract class CustomError extends Error {
    abstract statusCode: number;
    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, CustomError.prototype);
    }
    abstract serializeErrors(): { message: string; field?: string }[];
}
</file>

<file path="backend/src/errors/index.ts">
import { ZodError } from "zod";
import { CustomError } from "./CustomError";

export class BadRequestError extends CustomError {
    statusCode = 400;
    errorContent: string | ZodError;
    constructor(message: string | ZodError) {
        super(typeof message === "string" ? message : "Validation failed");
        this.errorContent = message;
        Object.setPrototypeOf(this, BadRequestError.prototype);
    }
    serializeErrors() {
        if (this.errorContent instanceof ZodError) {
            return this.errorContent.issues.map((issue) => ({
                message: issue.message,
                field: issue.path.join("."),
            }));
        }
        return [{ message: this.errorContent as string }];
    }
}

export class NotAuthorizedError extends CustomError {
    statusCode = 401;
    constructor(message = "Not authorized") {
        super(message);
        Object.setPrototypeOf(this, NotAuthorizedError.prototype);
    }
    serializeErrors() {
        return [{ message: this.message }];
    }
}

export class ForbiddenError extends CustomError {
    statusCode = 403;
    constructor(message = "Access forbidden") {
        super(message);
        Object.setPrototypeOf(this, ForbiddenError.prototype);
    }
    serializeErrors() {
        return [{ message: this.message }];
    }
}

export class NotFoundError extends CustomError {
    statusCode = 404;
    constructor(message = "Resource not found") {
        super(message);
        Object.setPrototypeOf(this, NotFoundError.prototype);
    }
    serializeErrors() {
        return [{ message: this.message }];
    }
}

export class ConflictError extends CustomError {
    statusCode = 409;
    constructor(message = "Resource already exists") {
        super(message);
        Object.setPrototypeOf(this, ConflictError.prototype);
    }
    serializeErrors() {
        return [{ message: this.message }];
    }
}

export class TooManyRequestsError extends CustomError {
    statusCode = 429;
    constructor(message = "Too many requests") {
        super(message);
        Object.setPrototypeOf(this, TooManyRequestsError.prototype);
    }
    serializeErrors() {
        return [{ message: this.message }];
    }
}

export class AppError extends CustomError {
    statusCode = 500;
    constructor(message = "Internal server error") {
        super(message);
        Object.setPrototypeOf(this, AppError.prototype);
    }
    serializeErrors() {
        return [{ message: this.message }];
    }
}

export { CustomError };
</file>

<file path="backend/src/middlewares/auth.middleware.ts">
/**
 * Authentication Middleware
 */
import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";
import { tokenConfig } from "../config/token.config";
import { NotAuthorizedError } from "../errors";

interface JwtPayload {
    id: string;
    role: string;
    iat: number;
    exp: number;
}

declare global {
    namespace Express {
        interface Request {
            user?: JwtPayload;
        }
    }
}

export function authMiddleware(req: Request, res: Response, next: NextFunction) {
    const authHeader = req.headers.authorization;
    const token = authHeader?.split(" ")[1];

    if (!token) {
        throw new NotAuthorizedError("Access token required");
    }

    try {
        const decoded = jwt.verify(token, tokenConfig.access.secret) as JwtPayload;
        req.user = decoded;
        next();
    } catch {
        throw new NotAuthorizedError("Invalid or expired token");
    }
}

export function optionalAuthMiddleware(req: Request, res: Response, next: NextFunction) {
    const authHeader = req.headers.authorization;
    const token = authHeader?.split(" ")[1];

    if (token) {
        try {
            const decoded = jwt.verify(token, tokenConfig.access.secret) as JwtPayload;
            req.user = decoded;
        } catch {
            // Token invalid, proceed as unauthenticated
        }
    }

    next();
}
</file>

<file path="backend/src/middlewares/cors.middleware.ts">
/**
 * CORS Middleware
 */
import cors from "cors";

const BACKEND_URL = process.env.BACKEND_URL || "http://localhost:5000";

export const corsMiddleware = cors({
    origin: (origin, callback) => {
        // In production, use env-based allowed origins
        const allowedOrigins = [
            BACKEND_URL,
            process.env.FRONTEND_URL,
            "http://localhost:3000",
            "http://localhost:3001",
            "http://localhost:5000",
        ].filter(Boolean); // Remove undefined values

        // Allow requests with no origin (mobile apps, Postman, etc.)
        if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            // In production, reject; in dev, allow all
            if (process.env.NODE_ENV === "production") {
                callback(new Error("Not allowed by CORS"));
            } else {
                callback(null, true);
            }
        }
    },
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"],
});
</file>

<file path="backend/src/middlewares/errorHandler.middleware.ts">
/**
 * Error Handler Middleware
 */
import { Request, Response, NextFunction } from "express";
import { CustomError } from "../errors";
import { logger } from "../utils/logger.util";

export function errorHandlerMiddleware(
    err: Error,
    req: Request,
    res: Response,
    next: NextFunction
): void {
    if (err instanceof CustomError) {
        res.status(err.statusCode).json({
            success: false,
            errors: err.serializeErrors(),
        });
        return;
    }

    logger.error(`[Error] ${err.message}`, { stack: err.stack });

    res.status(500).json({
        success: false,
        errors: [{ message: "Something went wrong" }],
    });
}
</file>

<file path="backend/src/middlewares/quizUpload.middleware.ts">
/**
 * Quiz Upload Middleware
 * Handles file upload configuration for quiz documents.
 */
import multer from "multer";
import path from "path";
import fs from "fs";

// Configure uploads directory
const uploadsDir = path.join(__dirname, "..", "..", "uploads", "documents");
if (!fs.existsSync(uploadsDir)) {
    fs.mkdirSync(uploadsDir, { recursive: true });
}

const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, uploadsDir);
    },
    filename: function (req, file, cb) {
        const uniqueName = `${Date.now()}-${Math.random().toString(36).substring(7)}-${file.originalname}`;
        cb(null, uniqueName);
    },
});

const quizDocumentUpload = multer({
    storage,
    limits: {
        fileSize: 50 * 1024 * 1024, // 50MB limit
    },
    fileFilter: function (req, file, cb) {
        const allowedTypes = [
            "application/pdf",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        ];
        if (allowedTypes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error("Only PDF and DOCX files are allowed"));
        }
    },
});

export const uploadQuizDocument = quizDocumentUpload.single("file");
export { uploadsDir };
</file>

<file path="backend/src/middlewares/rateLimiter.middleware.ts">
/**
 * Rate Limiter Middleware
 */
import rateLimit from "express-rate-limit";
import RedisStore from "rate-limit-redis";
import { redisClient } from "../utils/redis.util";

// API rate limiter
export const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 200,
    message: { success: false, message: "Too many requests, please try again later" },
    standardHeaders: true,
    legacyHeaders: false,
    ...(redisClient && {
        store: new RedisStore({
            sendCommand: (...args: string[]) => redisClient!.sendCommand(args),
        }),
    }),
});

// Auth rate limiter (stricter)
export const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 10,
    message: { success: false, message: "Too many login attempts, please try again later" },
    standardHeaders: true,
    legacyHeaders: false,
});
</file>

<file path="backend/src/middlewares/role.middleware.ts">
/**
 * Role Middleware
 */
import { Request, Response, NextFunction, RequestHandler } from "express";
import { ForbiddenError } from "../errors";

export function requireRole(...roles: string[]): RequestHandler {
    return function (req: Request, res: Response, next: NextFunction) {
        if (!req.user) {
            throw new ForbiddenError("Authentication required");
        }

        if (!roles.includes(req.user.role)) {
            throw new ForbiddenError("Insufficient permissions");
        }

        next();
    };
}

export const requireAdmin = requireRole("admin");
export const requireModerator = requireRole("admin", "moderator");
</file>

<file path="backend/src/middlewares/upload.middleware.ts">
/**
 * Upload Middleware (Multer)
 * Handles file uploads for documents, media, and avatars.
 */
import multer from "multer";
import { Request, Response, NextFunction } from "express";
import fs from "fs";
import path from "path";
import { v4 as uuidv4 } from "uuid";

// ===========================
// Upload Directories
// ===========================
const UPLOAD_BASE = path.join(process.cwd(), "uploads");
const TEMP_UPLOAD_DIR = path.join(UPLOAD_BASE, "temp");
const DOCUMENTS_DIR = path.join(UPLOAD_BASE, "documents");

// Ensure directories exist on startup
function ensureDirectories() {
    const dirs = [TEMP_UPLOAD_DIR, DOCUMENTS_DIR];
    for (const dir of dirs) {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
            console.log(`[Upload] Created directory: ${dir}`);
        }
    }
}
ensureDirectories();

// ===========================
// Allowed File Types
// ===========================

// Document types for quiz generation
const ALLOWED_DOCUMENT_MIMES: Record<string, string[]> = {
    // Word documents
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [".docx"],
    "application/msword": [".doc"],
    // PDF
    "application/pdf": [".pdf"],
    // Text files
    "text/plain": [".txt"],
    // Rich Text
    "application/rtf": [".rtf"],
    // OpenDocument
    "application/vnd.oasis.opendocument.text": [".odt"],
};

const ALLOWED_DOCUMENT_EXTENSIONS = [".pdf", ".docx", ".doc", ".txt", ".rtf", ".odt"];

// Media types (images/videos)
const ALLOWED_MEDIA_MIMES = ["image/", "video/"];

// ===========================
// File Filters
// ===========================

function documentFileFilter(req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) {
    const ext = path.extname(file.originalname).toLowerCase();
    const mime = file.mimetype;

    // Check by extension
    if (ALLOWED_DOCUMENT_EXTENSIONS.includes(ext)) {
        cb(null, true);
        return;
    }

    // Check by MIME type
    if (ALLOWED_DOCUMENT_MIMES[mime]) {
        cb(null, true);
        return;
    }

    cb(new Error(`Unsupported file type: ${ext}. Allowed: ${ALLOWED_DOCUMENT_EXTENSIONS.join(", ")}`));
}

function mediaFileFilter(req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) {
    if (file.mimetype.startsWith("image/") || file.mimetype.startsWith("video/")) {
        cb(null, true);
    } else {
        cb(new Error("Only image and video files are allowed!"));
    }
}

// ===========================
// Storage Configurations
// ===========================

// Temp storage for general uploads
const tempDiskStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, TEMP_UPLOAD_DIR);
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = `${Date.now()}-${uuidv4().substring(0, 8)}`;
        const ext = path.extname(file.originalname);
        cb(null, `${uniqueSuffix}${ext}`);
    },
});

// Document storage for quiz files
const documentDiskStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, DOCUMENTS_DIR);
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = `${Date.now()}-${uuidv4().substring(0, 8)}`;
        const ext = path.extname(file.originalname);
        // Keep original name for reference
        const safeName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, "_").substring(0, 50);
        cb(null, `${uniqueSuffix}-${safeName}`);
    },
});

// ===========================
// File Size Limits
// ===========================
const MAX_DOCUMENT_SIZE = 50 * 1024 * 1024; // 50MB for documents
const MAX_MEDIA_SIZE = 50 * 1024 * 1024; // 50MB for media
const MAX_AVATAR_SIZE = 5 * 1024 * 1024; // 5MB for avatars

// ===========================
// Export Multer Instances
// ===========================

// Document upload for quiz generation
export const uploadDocument = multer({
    storage: documentDiskStorage,
    fileFilter: documentFileFilter,
    limits: { fileSize: MAX_DOCUMENT_SIZE },
}).single("document");

// General file upload (temp)
export const uploadSingle = multer({
    storage: tempDiskStorage,
    fileFilter: mediaFileFilter,
    limits: { fileSize: MAX_MEDIA_SIZE },
}).single("file");

// Multiple files upload
export const uploadMultiple = multer({
    storage: tempDiskStorage,
    fileFilter: mediaFileFilter,
    limits: { fileSize: MAX_MEDIA_SIZE, files: 10 },
}).array("files", 10);

// Avatar upload (memory storage for processing)
export const uploadAvatar = multer({
    storage: multer.memoryStorage(),
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith("image/")) cb(null, true);
        else cb(new Error("Only image files are allowed!"));
    },
    limits: { fileSize: MAX_AVATAR_SIZE },
}).single("avatar");

// ===========================
// Utility Functions
// ===========================

export function cleanupTempFile(filePath: string): void {
    if (filePath && fs.existsSync(filePath)) {
        fs.promises.unlink(filePath).catch(() => { });
    }
}

export function getDocumentsDir(): string {
    return DOCUMENTS_DIR;
}

export function getTempDir(): string {
    return TEMP_UPLOAD_DIR;
}

// Export allowed extensions for frontend validation
export const ALLOWED_EXTENSIONS = ALLOWED_DOCUMENT_EXTENSIONS;
</file>

<file path="backend/src/middlewares/validation.middleware.ts">
/**
 * Validation Middleware (Zod)
 */
import { Request, Response, NextFunction, RequestHandler } from "express";
import { ZodSchema, ZodError } from "zod";
import { BadRequestError } from "../errors";

type ValidationTarget = "body" | "query" | "params";

export function validate(schema: ZodSchema, target: ValidationTarget = "body"): RequestHandler {
    return function (req: Request, res: Response, next: NextFunction) {
        try {
            const result = schema.safeParse(req[target]);
            if (!result.success) {
                throw new BadRequestError(result.error);
            }
            req[target] = result.data;
            next();
        } catch (error) {
            next(error);
        }
    };
}
</file>

<file path="backend/src/migrations/001-extract-questions.ts">
/**
 * Database Migration: Questions Extraction
 * 
 * Migrates embedded questions from Quiz documents to separate Question collection.
 * This improves performance and avoids MongoDB 16MB document limit.
 * 
 * Usage: npx ts-node src/migrations/001-extract-questions.ts
 */
import mongoose from "mongoose";
import dotenv from "dotenv";
import Quiz from "../models/quiz.model";
import Question from "../models/question.model";

dotenv.config();

async function runMigration() {
    const mongoUri = process.env.MONGO_URI || "mongodb://localhost:27017/quiz-app";

    console.log("🔄 Connecting to MongoDB...");
    await mongoose.connect(mongoUri);
    console.log("✅ Connected to MongoDB");

    try {
        // 1. Get all quizzes with embedded questions
        const quizzes = await Quiz.find({
            questions: { $exists: true, $ne: [] }
        }).lean();

        console.log(`📊 Found ${quizzes.length} quizzes with embedded questions`);

        let totalMigrated = 0;
        let totalFailed = 0;

        for (const quiz of quizzes) {
            const quizId = quiz._id;
            const questions = quiz.questions || [];

            if (questions.length === 0) continue;

            // Check if already migrated
            const existingCount = await Question.countDocuments({ quizId });
            if (existingCount > 0) {
                console.log(`⏭️  Quiz ${quizId}: Already migrated (${existingCount} questions)`);
                continue;
            }

            try {
                // 2. Create Question documents
                const questionDocs = questions.map((q: any, idx: number) => ({
                    quizId,
                    index: idx + 1,
                    stem: q.stem,
                    choices: q.choices,
                    correctAnswerKey: q.correctAnswerKey || "",
                    explanation: q.explanation || "",
                    source: q.source || "AI_Generated",
                    section: q.section || "",
                }));

                // 3. Bulk insert
                await Question.insertMany(questionDocs, { ordered: false });

                // 4. Update Quiz to clear embedded questions (optional - keep for backward compat)
                // await Quiz.updateOne(
                //     { _id: quizId },
                //     { $set: { questionsExtracted: true } }
                // );

                totalMigrated += questions.length;
                console.log(`✅ Quiz ${quizId}: Migrated ${questions.length} questions`);

            } catch (err: any) {
                totalFailed += questions.length;
                console.error(`❌ Quiz ${quizId}: Migration failed -`, err.message);
            }
        }

        console.log("\n" + "=".repeat(50));
        console.log("📈 MIGRATION SUMMARY");
        console.log("=".repeat(50));
        console.log(`✅ Total questions migrated: ${totalMigrated}`);
        console.log(`❌ Total questions failed: ${totalFailed}`);
        console.log(`📊 Total quizzes processed: ${quizzes.length}`);

        // 5. Create indexes if not exist
        console.log("\n🔧 Ensuring indexes...");
        await Question.collection.createIndex({ quizId: 1, index: 1 });
        await Question.collection.createIndex({ quizId: 1, section: 1 });
        console.log("✅ Indexes created");

    } catch (error) {
        console.error("❌ Migration failed:", error);
        process.exit(1);
    } finally {
        await mongoose.disconnect();
        console.log("\n🔌 Disconnected from MongoDB");
    }
}

// Run migration
runMigration()
    .then(() => {
        console.log("✅ Migration completed successfully");
        process.exit(0);
    })
    .catch((err) => {
        console.error("❌ Migration error:", err);
        process.exit(1);
    });
</file>

<file path="backend/src/models/aiTrace.model.ts">
/**
 * AI Trace Model
 * Logs AI input/output for debugging and auditing failed jobs.
 * Uses TTL index for automatic cleanup after 7 days.
 */
import mongoose, { Document, Schema, Types } from "mongoose";

export interface IAiTrace extends Document {
    _id: Types.ObjectId;
    quizId?: Types.ObjectId;
    jobId?: string;
    aiModel: string; // gemini-flash, deepseek-r1, etc.
    provider: "gemini" | "huggingface" | "ollama";
    inputPrompt: string; // Truncated to save space
    outputRaw: string; // Raw AI response
    parsedResult?: any; // Parsed JSON if successful
    error?: string;
    durationMs: number;
    tokenCount?: number;
    success: boolean;
    createdAt: Date;
}

const AiTraceSchema = new Schema<IAiTrace>(
    {
        quizId: { type: Schema.Types.ObjectId, ref: "Quiz", index: true },
        jobId: { type: String },
        aiModel: { type: String, required: true },
        provider: {
            type: String,
            enum: ["gemini", "huggingface", "ollama"],
            required: true
        },
        inputPrompt: { type: String, required: true },
        outputRaw: { type: String },
        parsedResult: { type: Schema.Types.Mixed },
        error: { type: String },
        durationMs: { type: Number, required: true },
        tokenCount: { type: Number },
        success: { type: Boolean, required: true },
    },
    { timestamps: true }
);

// TTL index: auto-delete after 7 days
AiTraceSchema.index({ createdAt: 1 }, { expireAfterSeconds: 604800 });

// Index for querying failed traces
AiTraceSchema.index({ success: 1, createdAt: -1 });

const AiTrace = mongoose.model<IAiTrace>("AiTrace", AiTraceSchema);

export default AiTrace;
</file>

<file path="backend/src/models/directory.model.ts">
/**
 * Directory Model
 * Hierarchical folder structure for organizing files.
 */
import mongoose, { Document, Schema, Types } from "mongoose";

export interface IDirectory extends Document {
    _id: Types.ObjectId;
    name: string;
    parentId: Types.ObjectId | null;
    creatorId: Types.ObjectId;
    isDeleted: boolean;
    createdAt: Date;
    updatedAt: Date;
}

const directorySchema = new Schema<IDirectory>(
    {
        name: { type: String, required: true, trim: true },
        parentId: {
            type: Schema.Types.ObjectId,
            ref: "Directory",
            default: null,
            index: true,
        },
        creatorId: {
            type: Schema.Types.ObjectId,
            ref: "User",
            required: true,
        },
        isDeleted: { type: Boolean, default: false, select: false },
    },
    {
        timestamps: true,
        collection: "directories",
        toJSON: {
            virtuals: true,
            transform: (doc, ret: any) => {
                ret.id = ret._id.toString();
                delete ret._id;
                delete ret.__v;
            },
        },
        toObject: {
            virtuals: true,
            transform: (doc, ret: any) => {
                ret.id = ret._id.toString();
                delete ret._id;
                delete ret.__v;
                delete ret.isDeleted;
            },
        },
    }
);

export default mongoose.model<IDirectory>("Directory", directorySchema);
</file>

<file path="backend/src/models/feedback.model.ts">
/**
 * Feedback Model
 */
import mongoose, { Document, Schema } from "mongoose";

export type FeedbackStatus = "pending_review" | "approved" | "rejected";

export interface IFeedback extends Document {
    userId: mongoose.Types.ObjectId;
    referenceId?: mongoose.Types.ObjectId;
    referenceType?: string;
    content: string;
    rating?: number;
    status: FeedbackStatus;
    adminId?: mongoose.Types.ObjectId;
    adminNotes?: string;
    isDeleted: boolean;
    createdAt: Date;
    updatedAt: Date;
}

const feedbackSchema = new Schema<IFeedback>(
    {
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
        referenceId: { type: Schema.Types.ObjectId },
        referenceType: String,
        content: { type: String, required: true, maxlength: 2000 },
        rating: { type: Number, min: 1, max: 5 },
        status: { type: String, enum: ["pending_review", "approved", "rejected"], default: "pending_review" },
        adminId: { type: Schema.Types.ObjectId, ref: "User" },
        adminNotes: { type: String, maxlength: 1000 },
        isDeleted: { type: Boolean, default: false },
    },
    { timestamps: true }
);

feedbackSchema.index({ userId: 1 });
feedbackSchema.index({ status: 1 });
feedbackSchema.index({ referenceId: 1, referenceType: 1 });

export default mongoose.model<IFeedback>("Feedback", feedbackSchema);
</file>

<file path="backend/src/models/globalQuestion.model.ts">
/**
 * GlobalQuestion Model
 * Semantic cache for quiz questions - prevents duplicate AI calls.
 * Questions are hashed after normalization for high cache hit rate.
 */
import mongoose, { Document, Schema, Types } from "mongoose";

// ==================== Interface ====================

export interface IGlobalQuestion extends Document {
    _id: Types.ObjectId;
    stemHash: string;           // MD5 of normalized stem
    stemPreview: string;        // First 100 chars for debugging
    choicesHash: string;        // MD5 of normalized choices (for exact match)
    correctKey: string;         // A, B, C, D
    explanation?: string;       // AI-generated explanation
    confidence?: number;        // AI confidence score (0-1)
    provider: string;           // Which AI provider answered
    hitCount: number;           // Cache efficiency tracking
    lastHitAt?: Date;           // Last time this was used
    createdAt: Date;
    updatedAt: Date;
}

// ==================== Schema ====================

const GlobalQuestionSchema = new Schema<IGlobalQuestion>(
    {
        stemHash: {
            type: String,
            required: true,
            index: true,
        },
        stemPreview: {
            type: String,
            required: true,
            maxlength: 150,
        },
        choicesHash: {
            type: String,
            required: true,
        },
        correctKey: {
            type: String,
            required: true,
            enum: ["A", "B", "C", "D"],
        },
        explanation: {
            type: String,
            default: "",
        },
        confidence: {
            type: Number,
            min: 0,
            max: 1,
        },
        provider: {
            type: String,
            required: true,
            enum: ["Gemini", "GitHub", "Groq", "HuggingFace", "Ollama", "Manual"],
        },
        hitCount: {
            type: Number,
            default: 0,
        },
        lastHitAt: {
            type: Date,
        },
    },
    {
        timestamps: true,
        collection: "global_questions",
    }
);

// Compound index for exact question matching
GlobalQuestionSchema.index({ stemHash: 1, choicesHash: 1 }, { unique: true });

// ==================== Normalization Helpers ====================

/**
 * Normalize stem for consistent hashing
 * - Lowercase
 * - Remove all whitespace
 * - Remove question number prefixes (Câu 1, 1., a., etc.)
 */
export function normalizeStem(stem: string): string {
    return stem
        .toLowerCase()
        // Remove Vietnamese question prefixes
        .replace(/^câu\s*\d+[\.:]/gi, "")
        // Remove numbered prefixes (1., 1), a., a))
        .replace(/^\d+[\.\)]\s*/gi, "")
        .replace(/^[a-z][\.\)]\s*/gi, "")
        // Remove all whitespace and special chars
        .replace(/\s+/g, "")
        .replace(/[^\p{L}\p{N}]/gu, "") // Keep only letters and numbers (Unicode)
        .trim();
}

/**
 * Normalize choices for hashing
 * Concatenate all choice texts, normalized
 */
export function normalizeChoices(choices: Array<{ key: string; text: string }>): string {
    return choices
        .sort((a, b) => a.key.localeCompare(b.key))
        .map(c => c.text.toLowerCase().replace(/\s+/g, ""))
        .join("|");
}

/**
 * Generate MD5 hash
 */
import crypto from "crypto";

export function hashString(input: string): string {
    return crypto.createHash("md5").update(input).digest("hex");
}

// ==================== Model ====================

const GlobalQuestion = mongoose.model<IGlobalQuestion>("GlobalQuestion", GlobalQuestionSchema);

export default GlobalQuestion;
</file>

<file path="backend/src/models/media.model.ts">
/**
 * Media Model
 */
import mongoose, { Document, Schema } from "mongoose";

export interface IMedia extends Document {
    name: string;
    type: string;
    mediaPath: string;
    size: number;
    width?: number;
    height?: number;
    directoryId?: mongoose.Types.ObjectId;
    uploader: mongoose.Types.ObjectId;
    tags?: string[];
    isDeleted: boolean;
    createdAt: Date;
    updatedAt: Date;
}

const mediaSchema = new Schema<IMedia>(
    {
        name: { type: String, required: true, trim: true },
        type: { type: String, required: true },
        mediaPath: { type: String, required: true },
        size: { type: Number, required: true },
        width: Number,
        height: Number,
        directoryId: { type: Schema.Types.ObjectId, ref: "Directory", default: null },
        uploader: { type: Schema.Types.ObjectId, ref: "User", required: true },
        tags: [String],
        isDeleted: { type: Boolean, default: false },
    },
    { timestamps: true }
);

mediaSchema.index({ uploader: 1 });
mediaSchema.index({ directoryId: 1 });

export default mongoose.model<IMedia>("Media", mediaSchema);
</file>

<file path="backend/src/models/otp.model.ts">
/**
 * OTP Model
 */
import mongoose, { Document, Schema } from "mongoose";

export enum OtpType {
    EMAIL_VERIFICATION = "email_verification",
    PASSWORD_RESET = "password_reset",
}

export interface IOtp extends Document {
    email: string;
    otp: string;
    type: OtpType;
    expiresAt: Date;
    createdAt: Date;
}

const otpSchema = new Schema<IOtp>(
    {
        email: { type: String, required: true, lowercase: true, trim: true },
        otp: { type: String, required: true },
        type: { type: String, enum: Object.values(OtpType), required: true },
        expiresAt: { type: Date, required: true, default: () => new Date(Date.now() + 10 * 60 * 1000) },
    },
    { timestamps: true }
);

otpSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
otpSchema.index({ email: 1, type: 1 });

export default mongoose.model<IOtp>("Otp", otpSchema);
</file>

<file path="backend/src/models/plan.model.ts">
/**
 * Plan Model
 * Subscription plans with pricing and feature limits.
 */
import mongoose, { Document, Schema, Types } from "mongoose";

export interface IPlan extends Document {
    _id: Types.ObjectId;
    name: string;
    slug: string;
    priceMonthly: number;
    priceYearly: number;
    tokenAllotment: number;
    featureLimit: number;
    storageLimit: number; // in MB
    apiAccess: boolean;
    isDeleted: boolean;
    createdAt: Date;
    updatedAt: Date;
}

const planSchema = new Schema<IPlan>(
    {
        name: { type: String, required: true },
        slug: { type: String, required: true, unique: true },
        priceMonthly: { type: Number, required: true, min: 0 },
        priceYearly: { type: Number, required: true, min: 0 },
        tokenAllotment: { type: Number, required: true, min: 0 },
        featureLimit: { type: Number, required: true, default: 10 },
        storageLimit: { type: Number, required: true, default: 100 }, // MB
        apiAccess: { type: Boolean, default: false },
        isDeleted: { type: Boolean, default: false, select: false },
    },
    {
        timestamps: true,
        collection: "plans",
        toJSON: {
            virtuals: true,
            transform: (doc, ret: any) => {
                ret.id = ret._id;
                delete ret._id;
                delete ret.__v;
                delete ret.isDeleted;
            },
        },
    }
);

export default mongoose.model<IPlan>("Plan", planSchema);
</file>

<file path="backend/src/models/product.model.ts">
/**
 * Product Model (Sample)
 */
import mongoose, { Document, Schema } from "mongoose";

export interface IProduct extends Document {
    name: string;
    description: string;
    price: number;
    stock: number;
    images: string[];
    category?: string;
    owner: mongoose.Types.ObjectId;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
}

const productSchema = new Schema<IProduct>(
    {
        name: {
            type: String,
            required: true,
            trim: true,
        },
        description: {
            type: String,
            required: true,
        },
        price: {
            type: Number,
            required: true,
            min: 0,
        },
        stock: {
            type: Number,
            default: 0,
            min: 0,
        },
        images: [String],
        category: String,
        owner: {
            type: Schema.Types.ObjectId,
            ref: "User",
            required: true,
        },
        isActive: {
            type: Boolean,
            default: true,
        },
    },
    { timestamps: true }
);

productSchema.index({ name: "text", description: "text" });
productSchema.index({ owner: 1 });
productSchema.index({ category: 1 });

export default mongoose.model<IProduct>("Product", productSchema);
</file>

<file path="backend/src/models/question.model.ts">
/**
 * Question Model (Separate Collection)
 * Extracted from Quiz for better performance and scalability.
 * Avoids MongoDB 16MB document limit for quizzes with many questions.
 */
import mongoose, { Document, Schema, Types } from "mongoose";
import { AnswerSource } from "./quiz.model";

export interface IChoice {
    key: string; // A, B, C, D
    text: string;
    isVisuallyMarked?: boolean;
}

export interface IQuestionDoc extends Document {
    _id: Types.ObjectId;
    quizId: Types.ObjectId;
    index: number; // Question order within quiz
    stem: string;
    choices: IChoice[];
    correctAnswerKey: string;
    explanation?: string;
    aiExplanation?: string; // On-demand AI explanation
    source: AnswerSource;
    section?: string;
    createdAt: Date;
    updatedAt: Date;
}

const ChoiceSchema = new Schema<IChoice>(
    {
        key: { type: String, required: true },
        text: { type: String, required: true },
        isVisuallyMarked: { type: Boolean, default: false },
    },
    { _id: false }
);

const QuestionSchema = new Schema<IQuestionDoc>(
    {
        quizId: {
            type: Schema.Types.ObjectId,
            ref: "Quiz",
            required: true,
            index: true
        },
        index: { type: Number, required: true },
        stem: { type: String, required: true },
        choices: { type: [ChoiceSchema], default: [] },
        correctAnswerKey: { type: String, default: "" },
        explanation: { type: String },
        aiExplanation: { type: String },
        source: {
            type: String,
            enum: Object.values(AnswerSource),
            default: AnswerSource.AI_Generated,
        },
        section: { type: String, default: "" },
    },
    { timestamps: true }
);

// Compound index for efficient quiz question queries
QuestionSchema.index({ quizId: 1, index: 1 });
QuestionSchema.index({ quizId: 1, section: 1 });

const Question = mongoose.model<IQuestionDoc>("Question", QuestionSchema);

export default Question;
</file>

<file path="backend/src/models/quiz.model.ts">
/**
 * Quiz Model
 * Represents a quiz generated from document parsing with embedded questions and choices.
 */
import mongoose, { Document, Schema, Types } from "mongoose";

// Enums
export enum AnswerSource {
    StyleDetected = "StyleDetected",
    AI_Generated = "AI_Generated",
    Manual = "Manual",
}

export enum QuizStatus {
    Pending = "pending",
    Processing = "processing",
    Waiting_AI = "waiting_ai",  // Graceful postponement - waiting for AI retry
    Completed = "completed",
    Failed = "failed",
    Needs_Review = "needs_review",  // AI failed, manual review needed
}

// Interfaces
export interface IChoice {
    key: string; // A, B, C, D
    text: string;
    isVisuallyMarked: boolean;
}

export interface IQuestion {
    _id?: Types.ObjectId;
    stem: string;
    choices: IChoice[];
    correctAnswerKey: string;
    explanation?: string;
    source: AnswerSource;
    section?: string; // Section/chapter this question belongs to
}

export interface IQuiz extends Document {
    _id: Types.ObjectId;
    title: string;
    documentUrl: string; // Google Drive link or local file
    documentType: "pdf" | "docx";
    fileHash?: string; // MD5 hash for deduplication
    status: QuizStatus;
    questions: IQuestion[];
    totalQuestions: number;
    processedQuestions: number;
    sections?: string[]; // Unique section names
    sectionCounts?: { name: string; count: number }[]; // Array of section counts
    errorMessage?: string;
    debugJsonPath?: string; // Path to debug JSON file with parsed results
    createdBy: Types.ObjectId;
    isDeleted: boolean;
    createdAt: Date;
    updatedAt: Date;
}

// Schemas
const ChoiceSchema = new Schema<IChoice>(
    {
        key: { type: String, required: true },
        text: { type: String, required: true },
        isVisuallyMarked: { type: Boolean, default: false },
    },
    { _id: false }
);

const QuestionSchema = new Schema<IQuestion>(
    {
        stem: { type: String, required: true },
        choices: { type: [ChoiceSchema], default: [] },
        correctAnswerKey: { type: String, default: "" },
        explanation: { type: String },
        source: {
            type: String,
            enum: Object.values(AnswerSource),
            default: AnswerSource.StyleDetected,
        },
        section: { type: String, default: "" }, // Section/chapter
    },
    { _id: true, strict: false } // Allow new fields
);

const QuizSchema = new Schema<IQuiz>(
    {
        title: { type: String, required: true },
        documentUrl: { type: String, required: true },
        documentType: {
            type: String,
            enum: ["pdf", "docx"],
            required: true,
        },
        status: {
            type: String,
            enum: Object.values(QuizStatus),
            default: QuizStatus.Pending,
        },
        questions: { type: [QuestionSchema], default: [] },
        totalQuestions: { type: Number, default: 0 },
        processedQuestions: { type: Number, default: 0 },
        sections: { type: [String], default: [] }, // Unique section names
        sectionCounts: { type: [{ name: String, count: Number }], default: [] }, // Array of section counts
        errorMessage: { type: String },
        debugJsonPath: { type: String }, // Path to debug JSON
        fileHash: { type: String, index: true }, // MD5 hash for deduplication
        createdBy: { type: Schema.Types.ObjectId, ref: "User", required: true },
        isDeleted: { type: Boolean, default: false },
    },
    {
        timestamps: true,
    }
);

// Indexes
QuizSchema.index({ createdBy: 1, createdAt: -1 });
QuizSchema.index({ status: 1 });

const Quiz = mongoose.model<IQuiz>("Quiz", QuizSchema);

export default Quiz;
</file>

<file path="backend/src/models/subscription.model.ts">
/**
 * Subscription Model
 * User subscriptions with billing period and status.
 */
import mongoose, { Document, Schema, Types } from "mongoose";

export type SubscriptionStatus = "active" | "canceled" | "past_due" | "unpaid" | "trialing" | "pending_approval" | "expired";
export type BillingPeriod = "monthly" | "yearly";
export type PaymentProvider = "stripe" | "paypal" | "momo" | "vnpay";

export interface ISubscription extends Document {
    _id: Types.ObjectId;
    userId: Types.ObjectId;
    planId: Types.ObjectId;
    planSlug: string;
    provider: PaymentProvider;
    providerSubscriptionId: string;
    status: SubscriptionStatus;
    billingPeriod: BillingPeriod;
    currentPeriodStart: Date;
    currentPeriodEnd: Date;
    canceledAt?: Date;
    cancelAtPeriodEnd: boolean;
    isDeleted: boolean;
    createdAt: Date;
    updatedAt: Date;
}

const subscriptionSchema = new Schema<ISubscription>(
    {
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true, index: true },
        planId: { type: Schema.Types.ObjectId, ref: "Plan", required: true },
        planSlug: { type: String, required: true },
        provider: { type: String, enum: ["stripe", "paypal", "momo", "vnpay"], required: true },
        providerSubscriptionId: { type: String, required: true, unique: true },
        status: {
            type: String,
            enum: ["active", "canceled", "past_due", "unpaid", "trialing", "pending_approval", "expired"],
            required: true,
        },
        billingPeriod: { type: String, enum: ["monthly", "yearly"], required: true },
        currentPeriodStart: { type: Date, required: true },
        currentPeriodEnd: { type: Date, required: true },
        canceledAt: { type: Date },
        cancelAtPeriodEnd: { type: Boolean, default: false },
        isDeleted: { type: Boolean, default: false, select: false },
    },
    {
        timestamps: true,
        collection: "subscriptions",
    }
);

subscriptionSchema.index({ userId: 1, status: 1 });

export default mongoose.model<ISubscription>("Subscription", subscriptionSchema);
</file>

<file path="backend/src/models/transaction.model.ts">
/**
 * Transaction Model
 * Payment transactions with gateway integration.
 */
import mongoose, { Document, Schema, Types } from "mongoose";

export type TransactionStatus = "pending" | "completed" | "failed" | "refunded";
export type PaymentGateway = "stripe" | "paypal" | "momo" | "vnpay";

export interface ITransaction extends Document {
    _id: Types.ObjectId;
    orderId: string;
    userId: Types.ObjectId;
    planId: Types.ObjectId;
    subscriptionId?: Types.ObjectId;
    planSlug: string;
    amount: number;
    currency: string;
    billingPeriod: "monthly" | "yearly";
    status: TransactionStatus;
    paymentGateway: PaymentGateway;
    gatewayTransactionId?: string;
    gatewayResponse?: string;
    createdAt: Date;
    updatedAt: Date;
}

const transactionSchema = new Schema<ITransaction>(
    {
        orderId: { type: String, required: true, unique: true, index: true },
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true, index: true },
        planId: { type: Schema.Types.ObjectId, ref: "Plan", required: true },
        subscriptionId: { type: Schema.Types.ObjectId, ref: "Subscription" },
        planSlug: { type: String, required: true },
        amount: { type: Number, required: true },
        currency: { type: String, default: "USD" },
        billingPeriod: { type: String, enum: ["monthly", "yearly"], required: true },
        status: {
            type: String,
            enum: ["pending", "completed", "failed", "refunded"],
            default: "pending",
        },
        paymentGateway: { type: String, enum: ["stripe", "paypal", "momo", "vnpay"], required: true },
        gatewayTransactionId: { type: String },
        gatewayResponse: { type: String },
    },
    {
        timestamps: true,
        collection: "transactions",
    }
);

export default mongoose.model<ITransaction>("Transaction", transactionSchema);
</file>

<file path="backend/src/models/user.model.ts">
/**
 * User Model
 */
import mongoose, { Document, Schema } from "mongoose";

export interface IUser extends Document {
    username: string;
    email: string;
    password: string;
    fullName?: string;
    avatarUrl?: string;
    role: "user" | "admin" | "moderator";
    isVerified: boolean;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
}

const userSchema = new Schema<IUser>(
    {
        username: {
            type: String,
            required: true,
            unique: true,
            lowercase: true,
            trim: true,
        },
        email: {
            type: String,
            required: true,
            unique: true,
            lowercase: true,
            trim: true,
        },
        password: {
            type: String,
            required: true,
            select: false,
        },
        fullName: String,
        avatarUrl: String,
        role: {
            type: String,
            enum: ["user", "admin", "moderator"],
            default: "user",
        },
        isVerified: {
            type: Boolean,
            default: false,
        },
        isActive: {
            type: Boolean,
            default: true,
        },
    },
    { timestamps: true }
);

// Note: email and username already have indexes from unique: true

export default mongoose.model<IUser>("User", userSchema);
</file>

<file path="backend/src/routes/admin.route.ts">
/**
 * Admin Routes
 */
import { Router } from "express";
import { authMiddleware } from "../middlewares/auth.middleware";
import { requireAdmin } from "../middlewares/role.middleware";
import { adminController } from "../controllers/admin.controller";

const router = Router();
router.use(authMiddleware);
router.use(requireAdmin);

router.get("/dashboard", adminController.getDashboard);
router.get("/users", adminController.listUsers);
router.patch("/users/:id/role", adminController.updateUserRole);
router.patch("/users/:id/status", adminController.updateUserStatus);

export default router;
</file>

<file path="backend/src/routes/auth.route.ts">
/**
 * Auth Routes
 */
import { Router } from "express";
import { validate } from "../middlewares/validation.middleware";
import { authLimiter } from "../middlewares/rateLimiter.middleware";
import { authController } from "../controllers/auth.controller";
import { registerSchema, loginSchema } from "../types/auth.types";

const router = Router();

router.post("/register", authLimiter, validate(registerSchema, "body"), authController.register);
router.post("/login", authLimiter, validate(loginSchema, "body"), authController.login);
router.post("/logout", authController.logout);
router.post("/refresh-token", authController.refreshToken);

export default router;
</file>

<file path="backend/src/routes/feedback.route.ts">
/**
 * Feedback Routes
 */
import { Router } from "express";
import { authMiddleware, optionalAuthMiddleware } from "../middlewares/auth.middleware";
import { validate } from "../middlewares/validation.middleware";
import { requireAdmin } from "../middlewares/role.middleware";
import { feedbackController } from "../controllers/feedback.controller";
import { createFeedbackSchema } from "../types/feedback.types";

const router = Router();

// Public routes
router.get("/reference/:type/:id", optionalAuthMiddleware, feedbackController.getByReference);
router.get("/reference/:type/:id/rating", feedbackController.getAverageRating);

// Protected routes
router.use(authMiddleware);

router.post("/", validate(createFeedbackSchema, "body"), feedbackController.create);
router.get("/my", feedbackController.getMyFeedbacks);
router.put("/:id", feedbackController.update);
router.delete("/:id", feedbackController.delete);

// Admin routes
router.patch("/:id/approve", requireAdmin, feedbackController.approve);
router.patch("/:id/reject", requireAdmin, feedbackController.reject);

export default router;
</file>

<file path="backend/src/routes/media.route.ts">
/**
 * Media Routes
 */
import { Router } from "express";
import { authMiddleware } from "../middlewares/auth.middleware";
import { uploadSingle, uploadMultiple } from "../middlewares/upload.middleware";
import { mediaController } from "../controllers/media.controller";

const router = Router();
router.use(authMiddleware);

router.post("/upload", uploadSingle, mediaController.uploadSingle);
router.post("/upload-multiple", uploadMultiple, mediaController.uploadMultiple);
router.get("/", mediaController.list);
router.get("/:id", mediaController.getById);
router.put("/:id", mediaController.update);
router.delete("/:id", mediaController.delete);

export default router;
</file>

<file path="backend/src/routes/product.route.ts">
/**
 * Product Routes
 */
import { Router } from "express";
import { authMiddleware, optionalAuthMiddleware } from "../middlewares/auth.middleware";
import { validate } from "../middlewares/validation.middleware";
import { productController } from "../controllers/product.controller";
import { createProductSchema } from "../types/product.types";

const router = Router();

// Public routes
router.get("/", optionalAuthMiddleware, productController.list);
router.get("/:id", productController.getById);

// Protected routes
router.post("/", authMiddleware, validate(createProductSchema, "body"), productController.create);
router.put("/:id", authMiddleware, productController.update);
router.delete("/:id", authMiddleware, productController.delete);

export default router;
</file>

<file path="backend/src/routes/quiz.route.ts">
import { Router } from "express";
import { authMiddleware, optionalAuthMiddleware } from "../middlewares/auth.middleware";
import { uploadQuizDocument } from "../middlewares/quizUpload.middleware";
import { quizController } from "../controllers/quiz.controller";

const router = Router();

/**
 * @swagger
 * /api/v1/quizzes/upload:
 *   post:
 *     summary: Upload a document to create a quiz
 *     tags: [Quizzes]
 *     security:
 *       - bearerAuth: []
 */
router.post("/upload", authMiddleware, uploadQuizDocument, quizController.uploadQuiz);

/**
 * @swagger
 * /api/v1/quizzes/debug/parse:
 *   post:
 *     summary: Debug endpoint - Parse file and return raw JSON (no database save)
 *     tags: [Quizzes]
 *     security:
 *       - bearerAuth: []
 */
router.post("/debug/parse", authMiddleware, uploadQuizDocument, quizController.debugParse);

/**
 * @swagger
 * /api/v1/quizzes/{id}/status:
 *   get:
 *     summary: Get quiz processing status
 *     tags: [Quizzes]
 */
router.get("/:id/status", optionalAuthMiddleware, quizController.getQuizStatus);

/**
 * @swagger
 * /api/v1/quizzes/{id}:
 *   get:
 *     summary: Get full quiz with questions
 *     tags: [Quizzes]
 */
router.get("/:id", optionalAuthMiddleware, quizController.getQuiz);

/**
 * @swagger
 * /api/v1/quizzes:
 *   get:
 *     summary: Get list of quizzes (public or user-specific if logged in)
 *     tags: [Quizzes]
 */
router.get("/", optionalAuthMiddleware, quizController.listQuizzes);

/**
 * @swagger
 * /api/v1/quizzes/{id}/questions/{qid}:
 *   put:
 *     summary: Update a specific question (manual correction)
 *     tags: [Quizzes]
 *     security:
 *       - bearerAuth: []
 */
router.put("/:id/questions/:qid", authMiddleware, quizController.updateQuestion);

/**
 * @swagger
 * /api/v1/quizzes/{id}:
 *   delete:
 *     summary: Delete a quiz
 *     tags: [Quizzes]
 *     security:
 *       - bearerAuth: []
 */
router.delete("/:id", authMiddleware, quizController.deleteQuiz);

/**
 * @swagger
 * /api/v1/quizzes/{id}/questions/{qid}/explain:
 *   post:
 *     summary: Get AI explanation when user answers incorrectly
 *     tags: [Quizzes]
 *     security:
 *       - bearerAuth: []
 */
router.post("/:id/questions/:qid/explain", optionalAuthMiddleware, quizController.explainWrongAnswer);

/**
 * @swagger
 * /api/v1/quizzes/{id}/download:
 *   get:
 *     summary: Download quiz as DOCX with highlighted correct answers
 *     tags: [Quizzes]
 */
router.get("/:id/download", optionalAuthMiddleware, quizController.downloadHighlightedDoc);

export default router;
</file>

<file path="backend/src/routes/user.route.ts">
/**
 * User Routes
 */
import { Router } from "express";
import { authMiddleware } from "../middlewares/auth.middleware";
import { userController } from "../controllers/user.controller";

const router = Router();
router.use(authMiddleware);

router.get("/me", userController.getMe);
router.put("/me", userController.updateMe);

export default router;
</file>

<file path="backend/src/routes/view.route.ts">
/**
 * View Routes
 * Routes for rendering EJS views
 */
import { Router, Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";

const router = Router();

// Helper to check if user might be logged in (has refresh token)
// Note: Access token is now stored in memory on frontend, not in cookies
// So we check refreshToken to determine auth state for SSR pages
function getUserFromToken(req: Request): any {
    try {
        // Check if refresh token exists - indicates user is logged in
        const refreshToken = req.cookies?.refreshToken;
        if (!refreshToken) {
            // No refresh token = definitely not logged in
            return null;
        }

        // Try to decode refresh token to get user id (for display purposes)
        // Don't verify signature here - just extract payload
        const decoded = jwt.decode(refreshToken) as { id: string } | null;
        if (decoded?.id) {
            // Return minimal user info - frontend will fetch full data via API
            return { id: decoded.id, _fromRefreshToken: true };
        }

        return null;
    } catch (error: any) {
        console.log('[ViewRoute] Token decode failed:', error.message);
        return null;
    }
}

// ===== Public Pages =====

// Home page
router.get("/", function homePage(req: Request, res: Response) {
    const user = getUserFromToken(req);
    res.render("pages/home", {
        title: "Trang chủ",
        user,
        flash: req.query.flash ? { [req.query.type as string]: req.query.flash } : null
    });
});

// Login page
router.get("/login", function loginPage(req: Request, res: Response) {
    const user = getUserFromToken(req);
    if (user) {
        res.redirect("/dashboard");
        return;
    }
    res.render("auth/login", {
        title: "Đăng nhập",
        user: null,
        error: req.query.error || null,
        flash: null
    });
});

// Register page
router.get("/register", function registerPage(req: Request, res: Response) {
    const user = getUserFromToken(req);
    if (user) {
        res.redirect("/dashboard");
        return;
    }
    res.render("auth/register", {
        title: "Đăng ký",
        user: null,
        error: req.query.error || null,
        flash: null
    });
});

// Logout
router.get("/logout", function logoutPage(req: Request, res: Response) {
    res.clearCookie("accessToken");
    res.clearCookie("refreshToken");
    res.redirect("/?type=success&flash=Đã đăng xuất thành công");
});

// ===== Protected Pages =====

// Dashboard - Public page (quizzes filtered by user if logged in)
router.get("/dashboard", function dashboardPage(req: Request, res: Response) {
    const user = getUserFromToken(req);
    res.render("pages/dashboard", {
        title: "Dashboard",
        user,
        flash: null
    });
});

// Upload page
router.get("/upload", function uploadPage(req: Request, res: Response) {
    const user = getUserFromToken(req);
    if (!user) {
        res.redirect("/login?error=Vui lòng đăng nhập");
        return;
    }
    res.render("quiz/upload", {
        title: "Upload tài liệu",
        user,
        flash: null
    });
});

// Quiz detail page (public - auth handled by frontend)
router.get("/quiz/:id", function quizDetailPage(req: Request, res: Response) {
    const user = getUserFromToken(req);
    res.render("quiz/detail", {
        title: "Chi tiết Quiz",
        user,
        quizId: req.params.id,
        flash: null
    });
});

// Quiz processing status page
router.get("/quiz/:id/status", function quizStatusPage(req: Request, res: Response) {
    const user = getUserFromToken(req);
    if (!user) {
        res.redirect("/login?error=Vui lòng đăng nhập");
        return;
    }
    res.render("quiz/processing", {
        title: "Trạng thái xử lý",
        user,
        quizId: req.params.id,
        flash: null
    });
});

// Quiz practice page
router.get("/quiz/:id/practice", function quizPracticePage(req: Request, res: Response) {
    const user = getUserFromToken(req);
    if (!user) {
        res.redirect("/login?error=Vui lòng đăng nhập");
        return;
    }
    res.render("quiz/practice", {
        title: "Làm bài Quiz",
        user,
        quizId: req.params.id,
        flash: null
    });
});

// ===== Error Pages =====

// 404 handler (will be added after all routes)
router.get("/404", function notFoundPage(req: Request, res: Response) {
    res.status(404).render("errors/404", {
        title: "Không tìm thấy",
        user: getUserFromToken(req),
        flash: null
    });
});

// 500 handler
router.get("/500", function serverErrorPage(req: Request, res: Response) {
    res.status(500).render("errors/500", {
        title: "Lỗi máy chủ",
        user: getUserFromToken(req),
        flash: null
    });
});

export default router;
</file>

<file path="backend/src/scripts/clearQueue.ts">
/**
 * Clear all quiz jobs from BullMQ queue
 */
import { Queue } from "bullmq";

const QUEUE_NAME = "quiz-processing";

async function clearQueue() {
    const queue = new Queue(QUEUE_NAME, {
        connection: {
            host: process.env.REDIS_HOST || "localhost",
            port: parseInt(process.env.REDIS_PORT || "6379"),
        },
    });

    console.log("Clearing quiz queue...");

    // Remove all jobs
    await queue.obliterate({ force: true });

    console.log("Queue cleared!");
    await queue.close();
    process.exit(0);
}

clearQueue().catch(console.error);
</file>

<file path="backend/src/server.ts">
/**
 * Server Entry Point
 * Starts the HTTP server and handles graceful shutdown.
 */
import http from "http";
import expressWs from "express-ws";
import app from "./app";
import { connectDB, closeDB } from "./config/db.config";
import { logger } from "./utils/logger.util";
import { stopSchedulers } from "./utils/scheduler.util";

async function startServer() {
    // Validate required environment variables
    const requiredEnvVars = ["JWT_SECRET", "MONGO_URI"];
    for (const envVar of requiredEnvVars) {
        if (!process.env[envVar]) {
            throw new Error(`${envVar} must be defined in .env file`);
        }
    }

    // Connect to database
    await connectDB();

    const PORT = process.env.PORT || 5000;

    // Create HTTP server with optional WebSocket support
    const server = http.createServer(app);
    const wsInstance = expressWs(app, server);
    const { app: wsApp } = wsInstance;

    // ===== WebSocket Endpoints =====
    wsApp.ws("/ws/notifications", (ws, req) => {
        logger.info("[WebSocket] Client connected to notifications");

        ws.on("message", (msg: string) => {
            try {
                const data = JSON.parse(msg.toString());
                logger.debug(`[WebSocket] Received: ${JSON.stringify(data)}`);
            } catch {
                logger.warn("[WebSocket] Invalid JSON received");
            }
        });

        ws.on("close", () => {
            logger.info("[WebSocket] Client disconnected");
        });
    });

    // Start HTTP server
    const httpServer = server.listen(PORT, () => {
        logger.info(`[Server] Running on http://localhost:${PORT}`);
        logger.info(`[Server] API Docs: http://localhost:${PORT}/api-docs`);
        logger.info(`[Server] Environment: ${process.env.NODE_ENV || "development"}`);
    });

    // ===== Graceful Shutdown =====
    async function gracefulShutdown(signal: string) {
        logger.info(`[Server] Received ${signal}. Starting graceful shutdown...`);

        httpServer.close(async () => {
            logger.info("[Server] HTTP server closed.");

            // Stop scheduled tasks
            stopSchedulers();

            // Close database connection
            await closeDB();

            logger.info("[Server] Graceful shutdown complete.");
            process.exit(0);
        });

        // Force shutdown after 10 seconds
        setTimeout(() => {
            logger.error("[Server] Could not close connections in time, forcefully shutting down");
            process.exit(1);
        }, 10000);
    }

    process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
    process.on("SIGINT", () => gracefulShutdown("SIGINT"));
}

startServer().catch((err) => {
    console.error("[Server] Failed to start:", err);
    process.exit(1);
});
</file>

<file path="backend/src/services/ai/aiOrchestrator.service.ts">
/**
 * AI Orchestrator Service
 * Manages the 5-layer AI fallback system with semantic caching.
 * 
 * Layers:
 * 0. Cache (GlobalQuestions) - Free, instant
 * 1. Gemini 1.5 Flash - Primary, high batch
 * 2. GitHub Models - Stable backup
 * 3. Groq Cloud - Fast inference
 * 4. HuggingFace - Last resort
 * 5. Graceful Postponement - Auto-retry later
 */
import GlobalQuestion, {
    normalizeStem,
    normalizeChoices,
    hashString
} from "../../models/globalQuestion.model";
import {
    geminiProvider,
    githubProvider,
    groqProvider,
    huggingFaceProvider
} from "./providers";
import {
    QuestionInput,
    AIResponse,
    OrchestratorResult,
    OrchestratorOptions,
    AIProviderName,
    BatchResult
} from "../../types/ai.types";
import { logger } from "../../utils/logger.util";

// ==================== Types ====================

interface CachedAnswer {
    index: number;
    correctKey: string;
    explanation?: string;
    provider: "Cache";
}

// ==================== Orchestrator ====================

export const aiOrchestrator = {
    /**
     * Solve questions using 5-layer fallback
     */
    async solveQuestions(
        questions: QuestionInput[],
        options: OrchestratorOptions = {}
    ): Promise<OrchestratorResult> {
        const startTime = Date.now();
        const { enableCache = true, maxRetries = 2 } = options;

        const result: OrchestratorResult = {
            responses: [],
            providersUsed: [],
            totalTokens: 0,
            cacheHits: 0,
            cacheMisses: 0,
            failedQuestions: 0,
            duration: 0,
        };

        // Step 1: Check cache for all questions
        let uncachedQuestions: QuestionInput[] = [];
        const cachedAnswers: Map<number, CachedAnswer> = new Map();

        if (enableCache) {
            for (const q of questions) {
                const cached = await this.checkCache(q);
                if (cached) {
                    cachedAnswers.set(q.index, cached);
                    result.cacheHits++;
                } else {
                    uncachedQuestions.push(q);
                    result.cacheMisses++;
                }
            }

            if (cachedAnswers.size > 0) {
                result.providersUsed.push("Cache");
                logger.info(`[AI Orchestrator] Cache hits: ${cachedAnswers.size}/${questions.length}`);
            }
        } else {
            uncachedQuestions = questions;
            result.cacheMisses = questions.length;
        }

        // Step 2: Call AI providers for uncached questions (with chunking)
        if (uncachedQuestions.length > 0) {
            // CHUNKING: Split into batches of 30 to avoid prompt length issues
            const BATCH_SIZE = 30;
            const chunks: QuestionInput[][] = [];
            for (let i = 0; i < uncachedQuestions.length; i += BATCH_SIZE) {
                chunks.push(uncachedQuestions.slice(i, i + BATCH_SIZE));
            }

            logger.info(`[AI Orchestrator] Processing ${uncachedQuestions.length} questions in ${chunks.length} batches`);

            for (const chunk of chunks) {
                const aiResult = await this.callProvidersWithFallback(chunk, maxRetries);

                result.providersUsed.push(...aiResult.providersUsed.filter(function (p) { return !result.providersUsed.includes(p); }));
                result.totalTokens += aiResult.totalTokens;
                result.failedQuestions += aiResult.failedQuestions;

                // Save new answers to cache
                if (enableCache && aiResult.responses.length > 0) {
                    await this.saveToCache(chunk, aiResult.responses, aiResult.providersUsed[0] || "Gemini");
                }

                // Merge AI responses
                for (const resp of aiResult.responses) {
                    result.responses.push(resp);
                }
            }
        }

        // Step 3: Add cached answers to responses
        for (const [index, cached] of cachedAnswers) {
            result.responses.push({
                index,
                correctKey: cached.correctKey,
                explanation: cached.explanation,
            });
        }

        // Sort by index
        result.responses.sort((a, b) => a.index - b.index);
        result.duration = Date.now() - startTime;

        logger.info(`[AI Orchestrator] Complete: ${result.responses.length} answers | Cache: ${result.cacheHits} | AI: ${result.cacheMisses} | Failed: ${result.failedQuestions} | ${result.duration}ms`);

        return result;
    },

    /**
     * Check cache for a single question
     */
    async checkCache(question: QuestionInput): Promise<CachedAnswer | null> {
        try {
            const stemHash = hashString(normalizeStem(question.stem));
            const choicesHash = hashString(normalizeChoices(question.choices));

            const cached = await GlobalQuestion.findOne({ stemHash, choicesHash });

            if (cached) {
                // Update hit count
                await GlobalQuestion.updateOne(
                    { _id: cached._id },
                    { $inc: { hitCount: 1 }, $set: { lastHitAt: new Date() } }
                );

                return {
                    index: question.index,
                    correctKey: cached.correctKey,
                    explanation: cached.explanation,
                    provider: "Cache",
                };
            }

            return null;
        } catch (error) {
            logger.error(`[AI Orchestrator] Cache check error:`, error);
            return null;
        }
    },

    /**
     * Save answers to cache
     */
    async saveToCache(
        questions: QuestionInput[],
        responses: AIResponse[],
        provider: AIProviderName
    ): Promise<void> {
        const operations = [];

        for (const resp of responses) {
            const question = questions.find(q => q.index === resp.index);
            if (!question) continue;

            const stemHash = hashString(normalizeStem(question.stem));
            const choicesHash = hashString(normalizeChoices(question.choices));
            const stemPreview = question.stem.substring(0, 100);

            operations.push({
                updateOne: {
                    filter: { stemHash, choicesHash },
                    update: {
                        $setOnInsert: {
                            stemHash,
                            stemPreview,
                            choicesHash,
                            correctKey: resp.correctKey,
                            explanation: resp.explanation || "",
                            provider,
                            hitCount: 0,
                        }
                    },
                    upsert: true,
                }
            });
        }

        if (operations.length > 0) {
            try {
                await GlobalQuestion.bulkWrite(operations);
                logger.info(`[AI Orchestrator] Cached ${operations.length} new answers`);
            } catch (error) {
                logger.error(`[AI Orchestrator] Cache save error:`, error);
            }
        }
    },

    /**
     * Call providers in priority order with fallback
     */
    async callProvidersWithFallback(
        questions: QuestionInput[],
        maxRetries: number
    ): Promise<{ responses: AIResponse[]; providersUsed: AIProviderName[]; totalTokens: number; failedQuestions: number }> {
        const providers = [
            geminiProvider,
            githubProvider,
            groqProvider,
            huggingFaceProvider,
        ];

        let responses: AIResponse[] = [];
        const providersUsed: AIProviderName[] = [];
        let totalTokens = 0;
        let remainingQuestions = [...questions];

        for (const provider of providers) {
            if (remainingQuestions.length === 0) break;

            const isAvailable = await provider.isAvailable();
            if (!isAvailable) {
                logger.debug(`[AI Orchestrator] ${provider.name} not available, skipping`);
                continue;
            }

            logger.info(`[AI Orchestrator] Trying ${provider.name} for ${remainingQuestions.length} questions`);

            let retries = 0;
            while (retries < maxRetries && remainingQuestions.length > 0) {
                const result = await provider.solveBatch(remainingQuestions);

                if (result.questionsAnswered > 0) {
                    responses.push(...result.responses);
                    providersUsed.push(provider.name);
                    totalTokens += result.tokensUsed;

                    // Remove answered questions from remaining
                    const answeredIndices = new Set(result.responses.map(r => r.index));
                    remainingQuestions = remainingQuestions.filter(q => !answeredIndices.has(q.index));
                    break;
                }

                // Check if rate limited
                const status = provider.getRateLimitStatus?.();
                if (status && status.remaining === 0) {
                    logger.warn(`[AI Orchestrator] ${provider.name} rate limited, moving to next provider`);
                    break;
                }

                retries++;
                if (retries < maxRetries) {
                    await new Promise(r => setTimeout(r, 1000 * retries)); // Exponential backoff
                }
            }
        }

        return {
            responses,
            providersUsed,
            totalTokens,
            failedQuestions: remainingQuestions.length,
        };
    },

    /**
     * Get cache statistics
     */
    async getCacheStats(): Promise<{ totalCached: number; totalHits: number }> {
        const stats = await GlobalQuestion.aggregate([
            {
                $group: {
                    _id: null,
                    totalCached: { $sum: 1 },
                    totalHits: { $sum: "$hitCount" },
                }
            }
        ]);

        return stats[0] || { totalCached: 0, totalHits: 0 };
    }
};
</file>

<file path="backend/src/services/ai/providers/base.provider.ts">
/**
 * Base AI Provider
 * Abstract class for all AI providers with common functionality.
 */
import { AIProvider, AIProviderName, BatchResult, QuestionInput, AIResponse } from "../../../types/ai.types";
import { logger } from "../../../utils/logger.util";

export abstract class BaseProvider implements AIProvider {
    abstract name: AIProviderName;
    abstract priority: number;

    protected apiKeys: string[] = [];
    protected currentKeyIndex: number = 0;
    protected lastRateLimitReset?: Date;
    protected rateLimitRemaining: number = Infinity;

    constructor(apiKeys: string | string[] = []) {
        this.apiKeys = Array.isArray(apiKeys) ? apiKeys : apiKeys.split(",").filter(k => k.trim());
    }

    /**
     * Get next API key (round-robin rotation)
     */
    protected getNextApiKey(): string | null {
        if (this.apiKeys.length === 0) return null;

        const key = this.apiKeys[this.currentKeyIndex];
        this.currentKeyIndex = (this.currentKeyIndex + 1) % this.apiKeys.length;
        return key;
    }

    /**
     * Check if provider has valid API keys
     */
    async isAvailable(): Promise<boolean> {
        return this.apiKeys.length > 0;
    }

    /**
     * Build prompt from questions
     */
    protected buildPrompt(questions: QuestionInput[]): string {
        const lines: string[] = [
            "You are a World-Class Professor. Analyze these multiple-choice questions and provide the correct answer.",
            "",
            "STRICT RULES:",
            "- Return ONLY a JSON object: {\"1\":\"A\", \"2\":\"C\", ...}",
            "- Use the question index as key",
            "- NO markdown, NO explanation, ONLY JSON",
            "",
            "QUESTIONS:"
        ];

        for (const q of questions) {
            lines.push(`\n[${q.index}] ${q.stem}`);
            for (const c of q.choices) {
                lines.push(`  ${c.key}. ${c.text}`);
            }
        }

        return lines.join("\n");
    }

    /**
     * Parse JSON response from AI
     */
    protected parseResponse(content: string, questions: QuestionInput[]): AIResponse[] {
        const results: AIResponse[] = [];

        try {
            // Extract JSON from response (handle markdown code blocks)
            let jsonStr = content;
            const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
            if (jsonMatch) {
                jsonStr = jsonMatch[1];
            }

            // Clean and parse
            jsonStr = jsonStr.replace(/[\r\n]/g, "").trim();
            const parsed = JSON.parse(jsonStr);

            for (const q of questions) {
                const key = parsed[q.index.toString()] || parsed[q.index] || "A";
                results.push({
                    index: q.index,
                    correctKey: key.toUpperCase(),
                });
            }
        } catch (error) {
            logger.error(`[${this.name}] Failed to parse response:`, error);
            // Return fallback for all questions
            for (const q of questions) {
                results.push({
                    index: q.index,
                    correctKey: "A", // Fallback
                });
            }
        }

        return results;
    }

    /**
     * Handle rate limit response
     */
    protected handleRateLimit(retryAfterSeconds?: number): void {
        this.rateLimitRemaining = 0;
        this.lastRateLimitReset = new Date(Date.now() + (retryAfterSeconds || 60) * 1000);
        logger.warn(`[${this.name}] Rate limited. Reset at: ${this.lastRateLimitReset.toISOString()}`);
    }

    /**
     * Get rate limit status
     */
    getRateLimitStatus(): { remaining: number; resetAt: Date } {
        return {
            remaining: this.rateLimitRemaining,
            resetAt: this.lastRateLimitReset || new Date(),
        };
    }

    /**
     * Log token usage
     */
    protected logTokenUsage(tokensUsed: number, questionsCount: number, duration: number): void {
        logger.info(`[AI] Provider: ${this.name} | Questions: ${questionsCount} | Tokens: ${tokensUsed} | Time: ${duration}ms`);
    }

    /**
     * Abstract method - implement in each provider
     */
    abstract solveBatch(questions: QuestionInput[]): Promise<BatchResult>;
}
</file>

<file path="backend/src/services/ai/providers/gemini.provider.ts">
/**
 * Gemini AI Provider (Primary - Layer 1)
 * Uses Google's Gemini 1.5 Flash for high-volume batch processing.
 * - 1M tokens/minute
 * - Batch size: 30-50 questions
 */
import { GoogleGenerativeAI } from "@google/generative-ai";
import { BaseProvider } from "./base.provider";
import { AIProviderName, BatchResult, QuestionInput } from "../../../types/ai.types";
import { logger } from "../../../utils/logger.util";

export class GeminiProvider extends BaseProvider {
    name: AIProviderName = "Gemini";
    priority = 1;

    private maxBatchSize = 40;

    constructor() {
        const keys = process.env.GEMINI_API_KEYS || process.env.GEMINI_API_KEY || "";
        super(keys);
    }

    async solveBatch(questions: QuestionInput[]): Promise<BatchResult> {
        const startTime = Date.now();
        const apiKey = this.getNextApiKey();

        if (!apiKey) {
            return {
                responses: [],
                provider: this.name,
                tokensUsed: 0,
                duration: 0,
                questionsAnswered: 0,
                questionsFailed: questions.length,
            };
        }

        try {
            const genAI = new GoogleGenerativeAI(apiKey);
            const model = genAI.getGenerativeModel({
                model: "gemini-1.5-flash",
                generationConfig: {
                    temperature: 0.1,
                    maxOutputTokens: 2048,
                    responseMimeType: "application/json", // Enable JSON mode
                }
            });

            const prompt = this.buildPrompt(questions);
            const result = await model.generateContent(prompt);
            const content = result.response.text();

            // Get token usage
            const tokensUsed = result.response.usageMetadata?.totalTokenCount || 0;
            const duration = Date.now() - startTime;

            const responses = this.parseResponse(content, questions);

            this.logTokenUsage(tokensUsed, questions.length, duration);

            return {
                responses,
                provider: this.name,
                tokensUsed,
                duration,
                questionsAnswered: responses.length,
                questionsFailed: 0,
            };

        } catch (error: any) {
            const duration = Date.now() - startTime;

            if (error.status === 429 || error.message?.includes("429")) {
                this.handleRateLimit(60);
            }

            logger.error(`[Gemini] Error:`, error.message);

            return {
                responses: [],
                provider: this.name,
                tokensUsed: 0,
                duration,
                questionsAnswered: 0,
                questionsFailed: questions.length,
            };
        }
    }

    getMaxBatchSize(): number {
        return this.maxBatchSize;
    }
}

export const geminiProvider = new GeminiProvider();
</file>

<file path="backend/src/services/ai/providers/github.provider.ts">
/**
 * GitHub Models Provider (Layer 2)
 * Uses GitHub's free AI models (gpt-4o-mini, Llama-3.1-70B).
 * Very stable, generous free limits with GitHub Token.
 */
import { BaseProvider } from "./base.provider";
import { AIProviderName, BatchResult, QuestionInput } from "../../../types/ai.types";
import { logger } from "../../../utils/logger.util";

const GITHUB_API_URL = "https://models.inference.ai.azure.com/chat/completions";

export class GitHubProvider extends BaseProvider {
    name: AIProviderName = "GitHub";
    priority = 2;

    private model: string;

    constructor() {
        const token = process.env.GITHUB_TOKEN || "";
        super(token);
        this.model = process.env.GITHUB_MODEL || "gpt-4o-mini";
    }

    async solveBatch(questions: QuestionInput[]): Promise<BatchResult> {
        const startTime = Date.now();
        const token = this.getNextApiKey();

        if (!token) {
            return this.emptyResult(questions.length);
        }

        try {
            const response = await fetch(GITHUB_API_URL, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}`,
                },
                body: JSON.stringify({
                    model: this.model,
                    messages: [
                        // Short system prompt to save input tokens (gpt-4o-mini is sensitive)
                        { role: "system", content: "You are a quiz solver. Return ONLY JSON: {\"1\":\"A\", \"2\":\"C\", ...}. No talk, no markdown." },
                        { role: "user", content: this.buildQuestionsOnlyPrompt(questions) }
                    ],
                    temperature: 0.1,
                    max_tokens: 2048,
                }),
            });

            if (response.status === 429) {
                const retryAfter = parseInt(response.headers.get("retry-after") || "60");
                this.handleRateLimit(retryAfter);
                return this.emptyResult(questions.length);
            }

            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.status}`);
            }

            const data = await response.json() as { choices?: Array<{ message?: { content?: string } }>; usage?: { total_tokens?: number } };
            const content = data.choices?.[0]?.message?.content || "{}";
            const tokensUsed = data.usage?.total_tokens || 0;
            const duration = Date.now() - startTime;

            const responses = this.parseResponse(content, questions);

            this.logTokenUsage(tokensUsed, questions.length, duration);

            return {
                responses,
                provider: this.name,
                tokensUsed,
                duration,
                questionsAnswered: responses.length,
                questionsFailed: 0,
            };

        } catch (error: any) {
            logger.error(`[GitHub] Error:`, error.message);
            return this.emptyResult(questions.length);
        }
    }

    /**
     * Build prompt with questions only (no instructions, since they're in system message)
     */
    private buildQuestionsOnlyPrompt(questions: QuestionInput[]): string {
        const lines: string[] = [];
        for (const q of questions) {
            lines.push(`[${q.index}] ${q.stem}`);
            for (const c of q.choices) {
                lines.push(`  ${c.key}. ${c.text}`);
            }
            lines.push("");
        }
        return lines.join("\n");
    }

    private emptyResult(failedCount: number): BatchResult {
        return {
            responses: [],
            provider: this.name,
            tokensUsed: 0,
            duration: 0,
            questionsAnswered: 0,
            questionsFailed: failedCount,
        };
    }
}

export const githubProvider = new GitHubProvider();
</file>

<file path="backend/src/services/ai/providers/groq.provider.ts">
/**
 * Groq Cloud Provider (Layer 3)
 * Ultra-fast inference with Llama 3.1 70B.
 * Good for single questions and explanations.
 */
import { BaseProvider } from "./base.provider";
import { AIProviderName, BatchResult, QuestionInput } from "../../../types/ai.types";
import { logger } from "../../../utils/logger.util";

const GROQ_API_URL = "https://api.groq.com/openai/v1/chat/completions";

export class GroqProvider extends BaseProvider {
    name: AIProviderName = "Groq";
    priority = 3;

    constructor() {
        const key = process.env.GROQ_API_KEY || "";
        super(key);
    }

    async solveBatch(questions: QuestionInput[]): Promise<BatchResult> {
        const startTime = Date.now();
        const apiKey = this.getNextApiKey();

        if (!apiKey) {
            return this.emptyResult(questions.length);
        }

        try {
            const prompt = this.buildPrompt(questions);

            const response = await fetch(GROQ_API_URL, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                },
                body: JSON.stringify({
                    model: "llama-3.1-70b-versatile",
                    messages: [
                        { role: "user", content: prompt }
                    ],
                    temperature: 0.1,
                    max_tokens: 2048,
                }),
            });

            if (response.status === 429) {
                this.handleRateLimit(60);
                return this.emptyResult(questions.length);
            }

            if (!response.ok) {
                throw new Error(`Groq API error: ${response.status}`);
            }

            const data = await response.json() as { choices?: Array<{ message?: { content?: string } }>; usage?: { total_tokens?: number } };
            const content = data.choices?.[0]?.message?.content || "{}";
            const tokensUsed = data.usage?.total_tokens || 0;
            const duration = Date.now() - startTime;

            const responses = this.parseResponse(content, questions);

            this.logTokenUsage(tokensUsed, questions.length, duration);

            return {
                responses,
                provider: this.name,
                tokensUsed,
                duration,
                questionsAnswered: responses.length,
                questionsFailed: 0,
            };

        } catch (error: any) {
            logger.error(`[Groq] Error:`, error.message);
            return this.emptyResult(questions.length);
        }
    }

    private emptyResult(failedCount: number): BatchResult {
        return {
            responses: [],
            provider: this.name,
            tokensUsed: 0,
            duration: 0,
            questionsAnswered: 0,
            questionsFailed: failedCount,
        };
    }
}

export const groqProvider = new GroqProvider();
</file>

<file path="backend/src/services/ai/providers/huggingface.provider.ts">
/**
 * Hugging Face Provider (Layer 4)
 * Serverless inference with Qwen/Mistral models.
 * Last resort before graceful postponement.
 */
import { HfInference } from "@huggingface/inference";
import { BaseProvider } from "./base.provider";
import { AIProviderName, BatchResult, QuestionInput } from "../../../types/ai.types";
import { logger } from "../../../utils/logger.util";

const HF_MODEL = "Qwen/Qwen2.5-72B-Instruct";

export class HuggingFaceProvider extends BaseProvider {
    name: AIProviderName = "HuggingFace";
    priority = 4;

    private hf: HfInference | null = null;

    constructor() {
        const token = process.env.HF_ACCESS_TOKEN || "";
        super(token);

        if (token) {
            this.hf = new HfInference(token);
        }
    }

    async isAvailable(): Promise<boolean> {
        return this.hf !== null;
    }

    async solveBatch(questions: QuestionInput[]): Promise<BatchResult> {
        const startTime = Date.now();

        if (!this.hf) {
            return this.emptyResult(questions.length);
        }

        try {
            const prompt = this.buildPrompt(questions);

            const response = await this.hf.chatCompletion({
                model: HF_MODEL,
                messages: [
                    { role: "user", content: prompt }
                ],
                max_tokens: 2048,
            });

            const content = response.choices?.[0]?.message?.content || "{}";
            const duration = Date.now() - startTime;

            // HF doesn't always provide token count
            const tokensUsed = 0;

            const responses = this.parseResponse(content, questions);

            this.logTokenUsage(tokensUsed, questions.length, duration);

            return {
                responses,
                provider: this.name,
                tokensUsed,
                duration,
                questionsAnswered: responses.length,
                questionsFailed: 0,
            };

        } catch (error: any) {
            logger.error(`[HuggingFace] Error:`, error.message);

            if (error.message?.includes("429") || error.message?.includes("rate")) {
                this.handleRateLimit(120);
            }

            return this.emptyResult(questions.length);
        }
    }

    private emptyResult(failedCount: number): BatchResult {
        return {
            responses: [],
            provider: this.name,
            tokensUsed: 0,
            duration: 0,
            questionsAnswered: 0,
            questionsFailed: failedCount,
        };
    }
}

export const huggingFaceProvider = new HuggingFaceProvider();
</file>

<file path="backend/src/services/ai/providers/index.ts">
/**
 * Provider Index
 * Exports all AI providers for the orchestrator.
 */
export { BaseProvider } from "./base.provider";
export { geminiProvider, GeminiProvider } from "./gemini.provider";
export { githubProvider, GitHubProvider } from "./github.provider";
export { groqProvider, GroqProvider } from "./groq.provider";
export { huggingFaceProvider, HuggingFaceProvider } from "./huggingface.provider";
</file>

<file path="backend/src/services/auth.service.ts">
/**
 * Auth Service
 */
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import User, { IUser } from "../models/user.model";
import { tokenConfig, refreshTokenCookieConfig } from "../config/token.config";
import { redisClient } from "../utils/redis.util";
import { NotAuthorizedError, BadRequestError, ConflictError, NotFoundError } from "../errors";

const REDIS_REFRESH_PREFIX = "refresh_tokens:";

function generateJti(): string {
    return crypto.randomBytes(16).toString("hex");
}

function generateTokens(user: IUser, jti: string) {
    const accessToken = jwt.sign(
        { id: user._id, role: user.role },
        tokenConfig.access.secret,
        { expiresIn: tokenConfig.access.expirationSeconds }
    );
    const refreshToken = jwt.sign(
        { id: user._id, jti },
        tokenConfig.refresh.secret,
        { expiresIn: tokenConfig.refresh.expirationSeconds }
    );
    return { accessToken, refreshToken };
}

export const authService = {
    async register(data: { username: string; email: string; password: string; fullName?: string }) {
        const { username, email, password, fullName } = data;
        const cleanEmail = email.trim().toLowerCase();
        const cleanUsername = username.trim().toLowerCase();

        const existing = await User.findOne({
            $or: [{ email: cleanEmail }, { username: cleanUsername }],
        });
        if (existing) {
            if (existing.email === cleanEmail) {
                throw new ConflictError("Email đã được sử dụng");
            }
            throw new ConflictError("Tên đăng nhập đã tồn tại");
        }

        const hashedPassword = await bcrypt.hash(password, 12);
        const user = await User.create({
            username: cleanUsername,
            email: cleanEmail,
            password: hashedPassword,
            fullName,
            isVerified: true,
        });

        return { message: "Đăng ký thành công!", userId: user._id };
    },

    async login(emailOrUsername: string, password: string) {
        const cleanInput = emailOrUsername.trim().toLowerCase();
        console.log("[Auth] Login attempt for:", cleanInput);

        // Tìm user bằng email HOẶC username
        const user = await User.findOne({
            $or: [{ email: cleanInput }, { username: cleanInput }],
            isActive: true
        }).select("+password");

        if (!user || !user.password) {
            console.log("[Auth] User not found or no password");
            throw new NotAuthorizedError("Email/tên đăng nhập hoặc mật khẩu không đúng");
        }

        console.log("[Auth] User found:", user.email, "Comparing passwords...");
        const isMatch = await bcrypt.compare(password, user.password);
        console.log("[Auth] Password match:", isMatch);

        if (!isMatch) {
            throw new NotAuthorizedError("Email/tên đăng nhập hoặc mật khẩu không đúng");
        }

        const jti = generateJti();
        const { accessToken, refreshToken } = generateTokens(user, jti);

        if (redisClient) {
            const key = `${REDIS_REFRESH_PREFIX}${user._id}`;
            await redisClient.sAdd(key, jti);
            await redisClient.expire(key, tokenConfig.refresh.expirationSeconds);
        }

        return {
            user: { id: user._id, username: user.username, email: user.email, role: user.role },
            tokens: { accessToken, refreshToken },
        };
    },

    async logout(refreshToken: string): Promise<void> {
        if (!refreshToken || !redisClient) return;
        try {
            const decoded = jwt.verify(refreshToken, tokenConfig.refresh.secret) as { id: string; jti: string };
            await redisClient.sRem(`${REDIS_REFRESH_PREFIX}${decoded.id}`, decoded.jti);
        } catch { }
    },

    async refreshToken(oldRefreshToken: string) {
        if (!oldRefreshToken) throw new BadRequestError("Refresh token required");
        if (!redisClient) throw new Error("Redis not available");

        let decoded: { id: string; jti: string };
        try {
            decoded = jwt.verify(oldRefreshToken, tokenConfig.refresh.secret) as typeof decoded;
        } catch {
            throw new NotAuthorizedError("Invalid refresh token");
        }

        const key = `${REDIS_REFRESH_PREFIX}${decoded.id}`;
        const isValid = await redisClient.sIsMember(key, decoded.jti);
        if (!isValid) {
            throw new NotAuthorizedError("Session invalid or expired");
        }

        const user = await User.findById(decoded.id);
        if (!user) throw new NotAuthorizedError("User not found");

        // Generate new access token
        const accessToken = jwt.sign(
            { id: user._id, role: user.role },
            tokenConfig.access.secret,
            { expiresIn: tokenConfig.access.expirationSeconds }
        );

        // Generate new refresh token with SAME jti but new expiry (sliding session)
        // This avoids race conditions - same jti stays valid in Redis
        const refreshToken = jwt.sign(
            { id: user._id, jti: decoded.jti },
            tokenConfig.refresh.secret,
            { expiresIn: tokenConfig.refresh.expirationSeconds }
        );

        // Extend session expiry in Redis
        await redisClient.expire(key, tokenConfig.refresh.expirationSeconds);

        return { accessToken, refreshToken };
    },
};
</file>

<file path="backend/src/services/document.service.ts">
/**
 * Document Service
 * Handles document parsing (PDF, DOCX) and DOCX generation.
 * Implements "Sticky Section" logic for auto-detecting section headers.
 */
import * as pdfjs from "pdfjs-dist/legacy/build/pdf";
import mammoth from "mammoth";
import {
    Document,
    Paragraph,
    TextRun,
    HeadingLevel,
    AlignmentType,
    Packer,
} from "docx";
import fs from "fs/promises";
import { existsSync } from "fs";
import path from "path";
import { ParsedChoice, ParsedDocument, ParsedQuestion } from "../types/quiz.types";
import { AnswerSource, IQuiz } from "../models/quiz.model";
import { logger } from "../utils/logger.util";

// ==================== Types ====================

interface SmartQuestion {
    stem: string;
    choices: ParsedChoice[];
    section: string;
}

// ==================== Constants ====================

const HIGHLIGHT_COLOR = "yellow";
const CORRECT_COLOR = "00AA00"; // Green

// Regex nhận diện tiêu đề "vạn năng"
// Tìm: Chương X, Bài X, Phần X, CLO X.X, Mục X, hoặc I, II, III...
const SECTION_REGEX = /(?:Chương|Bài|Phần|Mục|CLO|Chapter|Section|Part)\s*[\d\.]+|^[IVXLCDM]{1,5}[\.\s-]/gi;

// ==================== Parser Helpers ====================

function parseQuestionBlock(block: string, section: string): SmartQuestion | null {
    // Tìm điểm bắt đầu của đáp án A.
    const choiceAIndex = block.search(/\sA\./);
    if (choiceAIndex === -1) return null;

    // 1. Lấy thân câu hỏi (Stem) và làm sạch rác
    let stem = block.substring(0, choiceAIndex)
        .replace(/\s+/g, " ")
        .trim();

    // Làm sạch Stem: Xóa các dấu hiệu nhận diện tiêu đề và số thứ tự để lưu vào DB cho đẹp
    stem = stem
        .replace(/^(?:Chương|Bài|Phần|Mục|CLO)\s*[\d\.]+/i, "")
        .replace(/^\(CLO\s*\d+\.\d+\)/i, "")
        .replace(/^Câu\s*\d+[:.]/i, "")
        .replace(/^\d+[\.\)]/i, "")
        .trim();

    // 2. Tách đáp án A, B, C, D linh hoạt
    const choicesPart = block.substring(choiceAIndex);
    const choiceRegex = /\s([A-D])\.\s+([\s\S]*?)(?=\s[A-D]\.|$)/g;
    const matches = Array.from(choicesPart.matchAll(choiceRegex));

    const choices: ParsedChoice[] = matches.map(function (m) {
        return {
            key: m[1].toUpperCase(),
            text: m[2].replace(/\s+/g, " ").trim(),
            isVisuallyMarked: false
        };
    });

    if (choices.length < 2 || !stem) return null;

    return { stem, choices, section };
}

/**
 * Parse HTML question block and detect visual marks (bold, underline, red text, highlight)
 */
function parseHtmlQuestionBlock(htmlBlock: string, section: string): SmartQuestion | null {
    // Find start of choice A
    const choiceAIndex = htmlBlock.search(/\sA\./);
    if (choiceAIndex === -1) return null;

    // 1. Extract stem (remove HTML tags for clean text)
    let stem = htmlBlock.substring(0, choiceAIndex)
        .replace(/<[^>]*>/g, " ")
        .replace(/\s+/g, " ")
        .trim();

    // Clean stem: remove section markers and question numbers
    stem = stem
        .replace(/^(?:Chương|Bài|Phần|Mục|CLO)\s*[\d\.]+/i, "")
        .replace(/^\(CLO\s*\d+\.\d+\)/i, "")
        .replace(/^Câu\s*\d+[:.]/i, "")
        .replace(/^\d+[\.\\)]/i, "")
        .trim();

    // 2. Parse choices with visual mark detection
    const choicesPart = htmlBlock.substring(choiceAIndex);
    const choiceRegex = /\s([A-D])\.\s+([\s\S]*?)(?=(?:\s[A-D]\.)|$)/g;
    const matches = Array.from(choicesPart.matchAll(choiceRegex));

    const choices: ParsedChoice[] = matches.map(function (m) {
        const textWithTags = m[2];

        // Check for visual marks: bold, underline, red text, yellow highlight
        const isMarked = /<strong>|<b>|<u>|<span[^>]*style="[^"]*(?:color:\s*(?:red|#ff0000|rgb\(255,\s*0,\s*0\))|background-color:\s*yellow)/i.test(textWithTags);

        return {
            key: m[1].toUpperCase(),
            text: textWithTags.replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim(),
            isVisuallyMarked: isMarked
        };
    });

    if (choices.length < 2 || !stem) return null;
    return { stem, choices, section };
}

async function parseWithPdfjsStickySection(buffer: Buffer): Promise<SmartQuestion[]> {
    const uint8Array = new Uint8Array(buffer);
    const doc = await pdfjs.getDocument({ data: uint8Array }).promise;
    let fullText = "";

    // Bước 1: Trích xuất toàn bộ text
    for (let i = 1; i <= doc.numPages; i++) {
        const page = await doc.getPage(i);
        const content = await page.getTextContent();
        fullText += content.items.map(function (item: any) { return item.str; }).join(" ") + "\n";
    }

    // Bước 2: Tách văn bản thành các khối dựa trên câu hỏi
    const questionSplitRegex = /(?=\(CLO\s*\d+\.\d+\)|Câu\s*\d+[:.])|(?=\n\s*\d+[\.\)])/gi;
    const blocks = fullText.split(questionSplitRegex);

    const results: SmartQuestion[] = [];
    let currentSection = "Nội dung chung"; // Tiêu đề mặc định (Sticky)

    for (const block of blocks) {
        const cleanedBlock = block.trim();
        if (cleanedBlock.length < 10) continue;

        // KIỂM TRA XEM BLOCK NÀY CÓ CHỨA TIÊU ĐỀ MỚI KHÔNG
        // Nếu tiêu đề nằm ở ngay đầu khối văn bản, cập nhật currentSection
        const foundSection = cleanedBlock.match(new RegExp(`^${SECTION_REGEX.source}`, "i"));
        if (foundSection) {
            // Chỉ lấy phần Cha: CLO 1 thay vì CLO 1.1
            const rawSection = foundSection[0].toUpperCase();
            const majorOnly = rawSection.match(/^([A-ZÀ-Ỹ]+\s*\d+)/i);
            currentSection = majorOnly ? majorOnly[1].trim() : rawSection;
        } else {
            // Hoặc nếu tiêu đề nằm lẻ loi trong ngoặc (thường mã CLO)
            const cloInBlock = cleanedBlock.match(/\((?:CLO|Chương|Bài)\s*[\d\.]+\)/i);
            if (cloInBlock) {
                const rawClo = cloInBlock[0].replace(/[\(\)]/g, "").toUpperCase();
                const majorOnly = rawClo.match(/^([A-ZÀ-Ỹ]+\s*\d+)/i);
                currentSection = majorOnly ? majorOnly[1].trim() : rawClo;
            }
        }

        const parsed = parseQuestionBlock(cleanedBlock, currentSection);
        if (parsed) results.push(parsed);
    }

    // Log các section đã phát hiện
    const sections = Array.from(new Set(results.map(function (r) { return r.section; })));
    logger.info(`[DocumentService] PDF: Hoàn thành tách ${results.length} câu vào các mục: ${sections.join(", ")}`);

    return results;
}

function parseUniversalTextStickySection(rawText: string): SmartQuestion[] {
    // Normalize line breaks
    const normalizedText = rawText.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

    // Tách văn bản thành các khối dựa trên câu hỏi
    const questionSplitRegex = /(?=\(CLO\s*\d+\.\d+\)|Câu\s*\d+[:.])|(?=\n\s*\d+[\.\)])/gi;
    const blocks = normalizedText.split(questionSplitRegex);

    const results: SmartQuestion[] = [];
    let currentSection = "Nội dung chung"; // Tiêu đề mặc định (Sticky)

    for (const block of blocks) {
        const cleanedBlock = block.trim();
        if (cleanedBlock.length < 10) continue;

        // Kiểm tra tiêu đề mới
        const foundSection = cleanedBlock.match(new RegExp(`^${SECTION_REGEX.source}`, "i"));
        if (foundSection) {
            // Chỉ lấy phần Cha: CHƯƠNG 1 thay vì CHƯƠNG 1.1
            const rawSection = foundSection[0].toUpperCase();
            const majorOnly = rawSection.match(/^([A-ZÀ-Ỹ]+\s*\d+)/i);
            currentSection = majorOnly ? majorOnly[1].trim() : rawSection;
        } else {
            const cloInBlock = cleanedBlock.match(/\((?:CLO|Chương|Bài)\s*[\d\.]+\)/i);
            if (cloInBlock) {
                const rawClo = cloInBlock[0].replace(/[\(\)]/g, "").toUpperCase();
                const majorOnly = rawClo.match(/^([A-ZÀ-Ỹ]+\s*\d+)/i);
                currentSection = majorOnly ? majorOnly[1].trim() : rawClo;
            }
        }

        const parsed = parseQuestionBlock(cleanedBlock, currentSection);
        if (parsed) results.push(parsed);
    }

    const sections = Array.from(new Set(results.map(function (r) { return r.section; })));
    logger.info(`[DocumentService] DOCX: Hoàn thành tách ${results.length} câu vào các mục: ${sections.join(", ")}`);

    return results;
}

// ==================== Document Service ====================

export const documentService = {
    /**
     * Parse PDF file and extract questions with Sticky Section logic
     */
    async parsePdf(filePath: string): Promise<ParsedDocument> {
        try {
            const dataBuffer = await fs.readFile(filePath);
            const questions = await parseWithPdfjsStickySection(dataBuffer);

            return {
                title: "Tài liệu ôn thi tổng hợp",
                questions: questions.map(function (q, index) {
                    return {
                        index: index + 1,
                        stem: q.stem,
                        choices: q.choices,
                        section: q.section,
                        correctAnswerKey: "",
                        source: AnswerSource.AI_Generated,
                    } as ParsedQuestion;
                }),
            };
        } catch (error) {
            logger.error(`[DocumentService] PDF parse error:`, error);
            throw error;
        }
    },

    /**
     * Parse DOCX file and extract questions with Sticky Section logic
     * Uses HTML conversion to detect visual marks (bold, highlight, red text)
     */
    async parseDocx(filePath: string): Promise<ParsedDocument> {
        try {
            // Use convertToHtml to preserve formatting (bold, color, highlight)
            const result = await mammoth.convertToHtml({ path: filePath });
            const html = result.value;

            // Split into question blocks based on common patterns
            const questionSplitRegex = /(?=<p>(?:\(CLO\s*\d+\.\d+\)|Câu\s*\d+[:.]|\d+[\.\)]))/gi;
            const blocks = html.split(questionSplitRegex);

            const results: SmartQuestion[] = [];
            let currentSection = "Nội dung chung";

            for (const block of blocks) {
                const cleanedBlock = block.trim();
                if (cleanedBlock.length < 10) continue;

                // Update Sticky Section from HTML content
                const plainText = cleanedBlock.replace(/<[^>]*>/g, " ");
                const sectionMatch = plainText.match(/(?:Chương|Bài|Phần|Mục|CLO)\s*[\d\.]+/i);
                if (sectionMatch) {
                    const rawSection = sectionMatch[0].toUpperCase();
                    const majorOnly = rawSection.match(/^([A-ZÀ-Ỹ]+\s*\d+)/i);
                    currentSection = majorOnly ? majorOnly[1].trim() : rawSection;
                }

                // Parse question and detect visual marks
                const parsed = parseHtmlQuestionBlock(cleanedBlock, currentSection);
                if (parsed) results.push(parsed);
            }

            logger.info(`[DocumentService] DOCX HTML: Extracted ${results.length} questions`);

            return {
                title: "Tài liệu ôn thi tổng hợp",
                questions: results.map(function (q, index) {
                    // Find visually marked choice (correct answer)
                    const markedChoice = q.choices.find(function (c) { return c.isVisuallyMarked; });

                    return {
                        index: index + 1,
                        stem: q.stem,
                        choices: q.choices,
                        section: q.section,
                        // Use marked answer if found, otherwise leave for AI
                        correctAnswerKey: markedChoice?.key || "",
                        source: markedChoice ? AnswerSource.StyleDetected : AnswerSource.AI_Generated,
                    } as ParsedQuestion;
                }),
            };
        } catch (error) {
            logger.error(`[DocumentService] DOCX parse error:`, error);
            throw error;
        }
    },

    /**
     * Parse plain text file (.txt, .rtf as text)
     */
    async parseTxt(filePath: string): Promise<ParsedDocument> {
        try {
            const rawText = await fs.readFile(filePath, "utf-8");
            const questions = parseUniversalTextStickySection(rawText);

            return {
                title: "Tài liệu ôn thi tổng hợp",
                questions: questions.map(function (q, index) {
                    return {
                        index: index + 1,
                        stem: q.stem,
                        choices: q.choices,
                        section: q.section,
                        correctAnswerKey: "",
                        source: AnswerSource.AI_Generated,
                    } as ParsedQuestion;
                }),
            };
        } catch (error) {
            logger.error(`[DocumentService] TXT parse error:`, error);
            throw error;
        }
    },

    /**
     * Parse generic document - auto-detect format
     * Supports: .pdf, .docx, .doc, .txt, .rtf, .odt
     */
    async parseGenericDocument(filePath: string): Promise<ParsedDocument> {
        const ext = path.extname(filePath).toLowerCase();

        switch (ext) {
            case ".pdf":
                return this.parsePdf(filePath);

            case ".docx":
            case ".doc":
            case ".odt":
                // mammoth can handle these formats
                return this.parseDocx(filePath);

            case ".txt":
            case ".rtf":
                // Read as plain text
                return this.parseTxt(filePath);

            default:
                throw new Error(`Unsupported document format: ${ext}`);
        }
    },

    /**
     * Generate highlighted DOCX with correct answers marked
     */
    async generateHighlightedDocx(quiz: IQuiz): Promise<Buffer> {
        const children: Paragraph[] = [];

        // Title
        children.push(
            new Paragraph({
                text: quiz.title || "Quiz Đã Giải",
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER,
            })
        );

        children.push(new Paragraph({ text: "" }));

        // Info text
        children.push(
            new Paragraph({
                children: [
                    new TextRun({
                        text: `Tổng số câu hỏi: ${quiz.questions.length}`,
                        italics: true,
                    }),
                ],
            })
        );

        children.push(new Paragraph({ text: "" }));

        // Group questions by section
        let currentSection = "";

        quiz.questions.forEach(function (question: any, index: number) {
            // Add section header if changed
            if (question.section && question.section !== currentSection) {
                currentSection = question.section;
                children.push(new Paragraph({ text: "" }));
                children.push(
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: `📚 ${currentSection}`,
                                bold: true,
                                size: 28,
                                color: "4A5568",
                            }),
                        ],
                    })
                );
                children.push(new Paragraph({ text: "" }));
            }

            // Question stem
            children.push(
                new Paragraph({
                    children: [
                        new TextRun({
                            text: `Câu ${index + 1}: `,
                            bold: true,
                        }),
                        new TextRun({
                            text: question.stem,
                        }),
                    ],
                })
            );

            // Choices
            question.choices.forEach(function (choice: any) {
                const isCorrect = choice.key === question.correctAnswerKey;

                children.push(
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: `    ${choice.key}. ${choice.text}`,
                                bold: isCorrect,
                                color: isCorrect ? CORRECT_COLOR : undefined,
                                highlight: isCorrect ? HIGHLIGHT_COLOR : undefined,
                            }),
                            isCorrect
                                ? new TextRun({
                                    text: " ✓",
                                    bold: true,
                                    color: CORRECT_COLOR,
                                })
                                : new TextRun({ text: "" }),
                        ],
                    })
                );
            });

            children.push(new Paragraph({ text: "" }));
        });

        // Footer
        children.push(
            new Paragraph({
                children: [new TextRun({ text: "---" })],
                alignment: AlignmentType.CENTER,
            })
        );
        children.push(
            new Paragraph({
                children: [
                    new TextRun({
                        text: "Tạo bởi Quiz Generator - Đáp án đã được AI xác thực",
                        italics: true,
                        size: 20,
                    }),
                ],
                alignment: AlignmentType.CENTER,
            })
        );

        const doc = new Document({
            sections: [{ children }],
        });

        const buffer = await Packer.toBuffer(doc);
        logger.info(`[DocumentService] Generated highlighted DOCX for quiz ${quiz._id}`);

        return buffer;
    },

    /**
     * Save highlighted DOCX to file and return path
     */
    async saveHighlightedDocx(quiz: IQuiz, outputDir: string): Promise<string> {
        const buffer = await this.generateHighlightedDocx(quiz);

        const fileName = `quiz_${quiz._id}_highlighted.docx`;
        const filePath = path.join(outputDir, fileName);

        if (!existsSync(outputDir)) {
            await fs.mkdir(outputDir, { recursive: true });
        }

        await fs.writeFile(filePath, buffer);
        logger.info(`[DocumentService] Saved to ${filePath}`);

        return filePath;
    },
};
</file>

<file path="backend/src/services/email.service.ts">
/**
 * Email Service
 */
import nodemailer from "nodemailer";
import { logger } from "../utils/logger.util";

interface EmailOptions {
    to: string;
    subject: string;
    html: string;
}

class EmailService {
    private transporter: nodemailer.Transporter | null = null;
    private from: string;

    constructor() {
        this.from = process.env.EMAIL_FROM || "noreply@app.com";
        this.init();
    }

    private init(): void {
        if (!process.env.SMTP_HOST || !process.env.SMTP_USER) {
            logger.warn("[Email] SMTP not configured - emails disabled");
            return;
        }

        this.transporter = nodemailer.createTransport({
            host: process.env.SMTP_HOST,
            port: parseInt(process.env.SMTP_PORT || "587"),
            secure: process.env.SMTP_SECURE === "true",
            auth: {
                user: process.env.SMTP_USER,
                pass: process.env.SMTP_PASS,
            },
        });

        logger.info("[Email] SMTP configured");
    }

    async send(options: EmailOptions): Promise<boolean> {
        if (!this.transporter) {
            logger.warn("[Email] Skipped (not configured):", options.subject);
            return false;
        }

        try {
            await this.transporter.sendMail({
                from: this.from,
                to: options.to,
                subject: options.subject,
                html: options.html,
            });
            logger.info(`[Email] Sent to ${options.to}: ${options.subject}`);
            return true;
        } catch (error) {
            logger.error("[Email] Send failed:", error);
            return false;
        }
    }

    async sendWelcome(to: string, userName: string): Promise<boolean> {
        return this.send({
            to,
            subject: "Welcome to Our Platform!",
            html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1 style="color: #4f46e5;">Welcome, ${userName}!</h1>
          <p>Thank you for joining our platform. We're excited to have you!</p>
          <p>Get started by exploring our features.</p>
        </div>
      `,
        });
    }

    async sendVerificationOtp(to: string, userName: string, otp: string): Promise<boolean> {
        return this.send({
            to,
            subject: "Verify Your Email",
            html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1 style="color: #4f46e5;">Email Verification</h1>
          <p>Hi ${userName},</p>
          <p>Your verification code is:</p>
          <div style="background: #f3f4f6; padding: 20px; text-align: center; font-size: 32px; font-weight: bold; letter-spacing: 5px;">
            ${otp}
          </div>
          <p>This code expires in 10 minutes.</p>
        </div>
      `,
        });
    }

    async sendPasswordResetOtp(to: string, userName: string, otp: string): Promise<boolean> {
        return this.send({
            to,
            subject: "Password Reset",
            html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1 style="color: #4f46e5;">Password Reset</h1>
          <p>Hi ${userName},</p>
          <p>Your password reset code is:</p>
          <div style="background: #f3f4f6; padding: 20px; text-align: center; font-size: 32px; font-weight: bold; letter-spacing: 5px;">
            ${otp}
          </div>
          <p>This code expires in 10 minutes. If you didn't request this, please ignore.</p>
        </div>
      `,
        });
    }
}

export const emailService = new EmailService();
</file>

<file path="backend/src/services/feedback.service.ts">
/**
 * Feedback Service
 */
import mongoose, { Types } from "mongoose";
import Feedback, { IFeedback, FeedbackStatus } from "../models/feedback.model";
import { NotFoundError, BadRequestError, NotAuthorizedError } from "../errors";
import { logger } from "../utils/logger.util";

export const feedbackService = {
    async create(data: {
        userId: string;
        referenceId?: string;
        referenceType?: string;
        content: string;
        rating?: number;
    }): Promise<IFeedback> {
        return Feedback.create({
            userId: new Types.ObjectId(data.userId),
            referenceId: data.referenceId ? new Types.ObjectId(data.referenceId) : undefined,
            referenceType: data.referenceType,
            content: data.content,
            rating: data.rating,
            status: "pending_review",
        });
    },

    async findById(id: string): Promise<IFeedback | null> {
        return Feedback.findOne({ _id: id, isDeleted: false }).populate("userId", "username email");
    },

    async findByUser(userId: string, options: { page?: number; limit?: number } = {}) {
        const { page = 1, limit = 10 } = options;
        const filter = { userId: new Types.ObjectId(userId), isDeleted: false };

        const [total, data] = await Promise.all([
            Feedback.countDocuments(filter),
            Feedback.find(filter).sort({ createdAt: -1 }).skip((page - 1) * limit).limit(limit),
        ]);

        return { data, pagination: { total, page, limit, pages: Math.ceil(total / limit) } };
    },

    async findByReference(referenceId: string, referenceType: string, options: { page?: number; limit?: number; status?: FeedbackStatus } = {}) {
        const { page = 1, limit = 10, status } = options;
        const filter: any = { referenceId: new Types.ObjectId(referenceId), referenceType, isDeleted: false };
        if (status) filter.status = status;

        const [total, data] = await Promise.all([
            Feedback.countDocuments(filter),
            Feedback.find(filter).populate("userId", "username").sort({ createdAt: -1 }).skip((page - 1) * limit).limit(limit),
        ]);

        return { data, pagination: { total, page, limit, pages: Math.ceil(total / limit) } };
    },

    async update(id: string, userId: string, data: { content?: string; rating?: number }): Promise<IFeedback | null> {
        const feedback = await Feedback.findById(id);
        if (!feedback) throw new NotFoundError("Feedback not found");
        if (feedback.userId.toString() !== userId) throw new NotAuthorizedError("Not authorized");
        if (feedback.status !== "pending_review") throw new BadRequestError("Cannot edit processed feedback");

        if (data.content) feedback.content = data.content;
        if (data.rating) feedback.rating = data.rating;
        await feedback.save();
        return feedback;
    },

    async delete(id: string, userId: string): Promise<void> {
        const feedback = await Feedback.findById(id);
        if (!feedback) throw new NotFoundError("Feedback not found");
        if (feedback.userId.toString() !== userId) throw new NotAuthorizedError("Not authorized");
        feedback.isDeleted = true;
        await feedback.save();
    },

    async approve(id: string, adminId: string, notes?: string): Promise<IFeedback> {
        const feedback = await Feedback.findById(id);
        if (!feedback) throw new NotFoundError("Feedback not found");
        if (feedback.status !== "pending_review") throw new BadRequestError("Already processed");

        feedback.status = "approved";
        feedback.adminId = new Types.ObjectId(adminId);
        if (notes) feedback.adminNotes = notes;
        await feedback.save();
        logger.info(`[Feedback] Approved: ${id}`);
        return feedback;
    },

    async reject(id: string, adminId: string, reason?: string): Promise<IFeedback> {
        const feedback = await Feedback.findById(id);
        if (!feedback) throw new NotFoundError("Feedback not found");
        if (feedback.status !== "pending_review") throw new BadRequestError("Already processed");

        feedback.status = "rejected";
        feedback.adminId = new Types.ObjectId(adminId);
        if (reason) feedback.adminNotes = reason;
        await feedback.save();
        logger.info(`[Feedback] Rejected: ${id}`);
        return feedback;
    },

    async getAverageRating(referenceId: string, referenceType: string): Promise<{ average: number; count: number }> {
        const result = await Feedback.aggregate([
            { $match: { referenceId: new Types.ObjectId(referenceId), referenceType, status: "approved", isDeleted: false, rating: { $exists: true } } },
            { $group: { _id: null, average: { $avg: "$rating" }, count: { $sum: 1 } } },
        ]);
        return result[0] || { average: 0, count: 0 };
    },
};
</file>

<file path="backend/src/services/gemini.service.ts">
import { HfInference } from "@huggingface/inference";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { GeminiAnswerResponse } from "../types/quiz.types";
import { logger } from "../utils/logger.util";
import AiTrace from "../models/aiTrace.model";
import _ from "lodash";

const hf = new HfInference(process.env.HF_ACCESS_TOKEN);
const HF_MODEL = "Qwen/Qwen2.5-72B-Instruct";
const LOCAL_MODEL = "deepseek-r1:7b";
const LOCAL_OLLAMA_URL = "http://localhost:11434/api/chat";

// Gemini Flash - Primary (single request for all questions)
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "";
const genAI = GEMINI_API_KEY ? new GoogleGenerativeAI(GEMINI_API_KEY) : null;
const GEMINI_MODEL = "gemini-flash-latest";

// Prompt Injection Protection
const MAX_PROMPT_CHARS = 50000;
const INJECTION_PATTERNS = [
    /ignore\s+(all\s+)?(previous|above|prior)/gi,
    /forget\s+(everything|all|instructions)/gi,
    /disregard\s+(all|previous)/gi,
    /new\s+instructions?:/gi,
    /system\s*:\s*/gi,
];

function sanitizePrompt(text: string): string {
    let sanitized = text.slice(0, MAX_PROMPT_CHARS);
    for (const pattern of INJECTION_PATTERNS) {
        sanitized = sanitized.replace(pattern, "[FILTERED]");
    }
    return sanitized;
}

// Universal Prompt với Section Context
const UNIVERSAL_STRICT_PROMPT = `You are a World-Class Professor and Subject Matter Expert. 
I will provide a list of multiple-choice questions from a specialized document.

YOUR TASK:
1. Identify the subject matter from the provided questions and section context.
2. Analyze each question with high academic precision.
3. Determine the correct answer (A, B, C, or D) based on the context.
4. Return ONLY a single, compact JSON object.

JSON STRUCTURE: {"1":"A", "2":"C", ...}

STRICT RULES:
- NO markdown, NO preamble, NO explanations.
- Provide answers for ALL indices provided.
- If the document is in Vietnamese, ensure your internal reasoning accounts for Vietnamese technical terms.

QUESTIONS LIST:
`;

// Dynamic Explanation Prompt
const DYNAMIC_EXPLANATION_PROMPT = `Bạn là giảng viên chuyên ngành. 
Nhiệm vụ: Giải thích ngắn gọn (2-3 câu) tại sao đáp án đúng lại chính xác.

QUY TẮC:
- Tập trung vào kiến thức cốt lõi (Key Takeaway).
- Dùng thuật ngữ chuyên ngành phù hợp với môn học của câu hỏi.
- Ngôn ngữ: Tiếng Việt.
- Trả về: Chỉ chuỗi text giải thích, không tiêu đề.`;

export const aiService = {
    /**
     * Main entry: Gemini Flash (single request) → HF (batched) → Local Ollama
     */
    async detectAllAnswers(questions: any[]): Promise<GeminiAnswerResponse[]> {
        logger.info(`[AIService] Đang giải ${questions.length} câu hỏi...`);

        // 1. TRY GEMINI FLASH FIRST (single request for ALL questions)
        if (genAI) {
            try {
                logger.info(`[AIService] Thử Gemini Flash (1 request cho tất cả ${questions.length} câu)...`);
                const results = await this.solveWithGemini(questions);
                logger.info(`[AIService] ✓ Gemini Flash thành công!`);
                return results;
            } catch (error: any) {
                logger.warn(`[AIService] Gemini Flash lỗi: ${error.message}. Chuyển sang HF...`);
            }
        }

        // 2. FALLBACK TO HF (BATCHED)
        return this.detectWithHFBatched(questions);
    },

    /**
     * HF Batched with Local Ollama fallback per batch
     */
    async detectWithHFBatched(questions: any[]): Promise<GeminiAnswerResponse[]> {
        const BATCH_SIZE = 12;
        const chunks = _.chunk(questions, BATCH_SIZE);
        const results: GeminiAnswerResponse[] = [];

        logger.info(`[AIService] HF Batched: ${questions.length} câu (${chunks.length} lô)...`);

        for (let i = 0; i < chunks.length; i++) {
            const batch = chunks[i];
            const startIndex = i * BATCH_SIZE;

            try {
                const res = await this.solveWithHF(batch, startIndex);
                results.push(...res);
                logger.info(`[AIService] Lô ${i + 1}/${chunks.length} - HF thành công`);
            } catch (error: any) {
                if (error.message?.includes("limit") || error.status === 402 || error.status === 429) {
                    logger.warn(`[AIService] HF Hết limit! Chuyển sang Local lô ${i + 1}...`);
                    try {
                        const localRes = await this.solveWithLocalOllama(batch, startIndex);
                        results.push(...localRes);
                        logger.info(`[AIService] Lô ${i + 1}/${chunks.length} - Local thành công`);
                    } catch (localError) {
                        logger.error(`[AIService] Local cũng lỗi:`, localError);
                        batch.forEach(function () {
                            results.push({ correct_key: "A", explanation: "" });
                        });
                    }
                } else {
                    logger.error(`[AIService] Lỗi không xác định:`, error);
                    batch.forEach(function () {
                        results.push({ correct_key: "A", explanation: "" });
                    });
                }
            }
        }
        return results;
    },

    /**
     * Gemini Flash - Single request for ALL questions (primary, fastest)
     */
    async solveWithGemini(questions: any[], quizId?: string): Promise<GeminiAnswerResponse[]> {
        if (!genAI) throw new Error("GEMINI_API_KEY not configured");

        const prompt = sanitizePrompt(this.buildPromptForAll(questions));
        const model = genAI.getGenerativeModel({ model: GEMINI_MODEL });
        const startTime = Date.now();
        let content = "{}";
        let success = false;
        let error: string | undefined;

        try {
            const result = await model.generateContent(prompt);
            const response = await result.response;
            content = response.text() || "{}";
            success = true;
        } catch (err: any) {
            error = err.message;
            throw err;
        } finally {
            // Log AI trace for debugging
            await AiTrace.create({
                quizId,
                aiModel: GEMINI_MODEL,
                provider: "gemini",
                inputPrompt: prompt.slice(0, 10000), // Truncate for storage
                outputRaw: content.slice(0, 10000),
                durationMs: Date.now() - startTime,
                success,
                error,
            }).catch((e) => logger.warn(`[AIService] Trace save failed: ${e.message}`));
        }

        return this.parseGeminiResponse(content, questions);
    },

    /**
     * Build prompt for ALL questions (Gemini single request)
     */
    buildPromptForAll(questions: any[]): string {
        const questionsText = questions.map(function (q, idx) {
            const choicesStr = q.choices.map(function (c: any) {
                return `${c.key}.${c.text}`;
            }).join(" | ");
            const sectionInfo = q.section ? `(${q.section}) ` : "";
            return `[${idx + 1}] ${sectionInfo}${q.stem} -> ${choicesStr}`;
        }).join("\n");

        return `${UNIVERSAL_STRICT_PROMPT}${questionsText}`;
    },

    /**
     * Parse Gemini response (all questions at once)
     */
    parseGeminiResponse(content: string, questions: any[]): GeminiAnswerResponse[] {
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        let parsed: Record<string, string> = {};

        try {
            parsed = JSON.parse(jsonMatch ? jsonMatch[0] : "{}");
        } catch (e) {
            logger.warn("[AIService] Gemini JSON parse lỗi");
        }

        return questions.map(function (q, idx) {
            const id = String(idx + 1);
            const ans = parsed[id]?.toUpperCase() || "A";
            return {
                correct_key: ans,
                explanation: ""
            };
        });
    },

    // Gọi Hugging Face (72B)
    async solveWithHF(batch: any[], startIndex: number): Promise<GeminiAnswerResponse[]> {
        const prompt = this.buildPromptWithSection(batch, startIndex);
        const response = await hf.chatCompletion({
            model: HF_MODEL,
            messages: [{ role: "user", content: prompt }],
            max_tokens: 1500,
            // @ts-ignore
            response_format: { type: "json_object" }
        });
        const content = response.choices[0]?.message?.content || "{}";
        return this.parseAIResponse(content, batch, startIndex);
    },

    // Gọi Ollama Local (DeepSeek-R1-7B) - Optimized for small model
    async solveWithLocalOllama(batch: any[], startIndex: number): Promise<GeminiAnswerResponse[]> {
        // Split into smaller chunks for 7B model (max 4 questions per call)
        const LOCAL_BATCH = 4;
        const subChunks = _.chunk(batch, LOCAL_BATCH);
        const results: GeminiAnswerResponse[] = [];

        for (let i = 0; i < subChunks.length; i++) {
            const subBatch = subChunks[i];
            const subStartIndex = startIndex + (i * LOCAL_BATCH);

            const prompt = this.buildPromptForLocal(subBatch, subStartIndex);

            try {
                const response = await fetch(LOCAL_OLLAMA_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        model: LOCAL_MODEL,
                        messages: [{ role: "user", content: prompt }],
                        stream: false,
                        options: {
                            temperature: 0.1, // Very low for accuracy
                            num_predict: 1000
                        }
                    })
                });
                const data = await response.json() as { message?: { content?: string } };
                const content = data.message?.content || "{}";
                const parsed = this.parseAIResponse(content, subBatch, subStartIndex);
                results.push(...parsed);
            } catch (e) {
                logger.error("[Ollama] Sub-batch error, fallback A");
                subBatch.forEach(function () {
                    results.push({ correct_key: "A", explanation: "" });
                });
            }
        }
        return results;
    },

    // Build prompt for Local 7B (allow reasoning before JSON)
    buildPromptForLocal(batch: any[], startIndex: number): string {
        const questionsText = batch.map(function (q, idx) {
            const choicesStr = q.choices.map(function (c: any) {
                return `${c.key}. ${c.text}`;
            }).join("\n");
            const sectionInfo = q.section ? `[${q.section}] ` : "";
            return `Câu ${startIndex + idx + 1}: ${sectionInfo}${q.stem}\n${choicesStr}`;
        }).join("\n\n");

        return `Bạn là chuyên gia giải đề trắc nghiệm.

Hãy phân tích kỹ từng câu hỏi bên dưới. 
Với mỗi câu, hãy suy luận ngắn gọn để loại trừ các đáp án sai, rồi xác định đáp án đúng.

${questionsText}

SAU KHI suy luận xong, trả về KẾT QUẢ dạng JSON như sau:
{"${startIndex + 1}": "A", "${startIndex + 2}": "B", ...}

Chỉ cần trả về JSON kết quả cuối cùng.`;
    },

    // Build prompt with Section Context (for batched)
    buildPromptWithSection(batch: any[], startIndex: number): string {
        const questionsText = batch.map(function (q, idx) {
            const choicesStr = q.choices.map(function (c: any) {
                return `${c.key}.${c.text}`;
            }).join(" | ");
            const sectionInfo = q.section ? `(Section: ${q.section}) ` : "";
            return `[${startIndex + idx + 1}] ${sectionInfo}${q.stem} -> ${choicesStr}`;
        }).join("\n");

        return `${UNIVERSAL_STRICT_PROMPT}${questionsText}`;
    },

    // Parse AI response (for batched)
    parseAIResponse(content: string, batch: any[], startIndex: number): GeminiAnswerResponse[] {
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        let parsed: Record<string, string> = {};

        try {
            parsed = JSON.parse(jsonMatch ? jsonMatch[0] : "{}");
        } catch (e) {
            logger.warn("[AIService] JSON parse lỗi, fallback A cho tất cả");
        }

        return batch.map(function (q, idx) {
            const id = String(startIndex + idx + 1);
            const ans = parsed[id]?.toUpperCase() || "A";
            return {
                correct_key: ans,
                explanation: ""
            };
        });
    },

    // Giải thích chi tiết khi user trả lời sai - Chỉ dùng Local Ollama
    async generateExplanation(input: any): Promise<string> {
        const correctChoice = input.choices?.find(function (c: any) {
            return c.key === input.correctAnswerKey;
        });

        const userChoice = input.choices?.find(function (c: any) {
            return c.key === input.userAnswerKey;
        });

        const prompt = `Bạn là giảng viên chuyên ngành. Học sinh vừa trả lời SAI một câu hỏi trắc nghiệm.

Câu hỏi: ${input.questionStem}

Học sinh chọn: ${input.userAnswerKey}. ${userChoice?.text || ""}
Đáp án đúng: ${input.correctAnswerKey}. ${correctChoice?.text || ""}

Hãy giải thích ngắn gọn (2-3 câu):
1. Tại sao đáp án học sinh chọn là sai
2. Tại sao đáp án đúng lại chính xác

Trả lời bằng tiếng Việt, tập trung vào kiến thức cốt lõi.`;

        try {
            const response = await fetch(LOCAL_OLLAMA_URL, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    model: LOCAL_MODEL,
                    messages: [{ role: "user", content: prompt }],
                    stream: false,
                    options: {
                        temperature: 0.3,
                        num_predict: 500
                    }
                })
            });
            const data = await response.json() as { message?: { content?: string } };
            return data.message?.content?.trim() || `Đáp án đúng là ${input.correctAnswerKey}. Hãy xem lại kiến thức này.`;
        } catch (e) {
            logger.error("[Ollama] Explanation error:", e);
            return `Đáp án đúng là ${input.correctAnswerKey}. Bạn chọn ${input.userAnswerKey} là chưa chính xác. Hãy xem lại kiến thức liên quan.`;
        }
    }
};

// Export cũ để tương thích
export const geminiService = {
    detectAllAnswersSingleCall: aiService.detectAllAnswers.bind(aiService),
    generateWrongAnswerExplanation: aiService.generateExplanation.bind(aiService),
};
</file>

<file path="backend/src/services/media.service.ts">
/**
 * Media Service
 */
import mongoose, { Types } from "mongoose";
import Media, { IMedia } from "../models/media.model";
import { storageService } from "../utils/storage";
import { NotFoundError } from "../errors";
import { logger } from "../utils/logger.util";
import { v4 as uuidv4 } from "uuid";

export interface FindMediasOptions {
    page?: number;
    limit?: number;
    search?: string;
    type?: string;
    directoryId?: string | null;
    uploader?: string;
}

export const mediaService = {
    async create(data: {
        name: string;
        type: string;
        mediaPath: string;
        size: number;
        width?: number;
        height?: number;
        directoryId?: string | null;
        uploader: string;
        tags?: string[];
    }): Promise<IMedia> {
        return Media.create({
            ...data,
            uploader: new Types.ObjectId(data.uploader),
            directoryId: data.directoryId ? new Types.ObjectId(data.directoryId) : null,
        });
    },

    async findById(id: string): Promise<IMedia | null> {
        return Media.findOne({ _id: id, isDeleted: false });
    },

    async findAndPaginate(options: FindMediasOptions) {
        const { page = 1, limit = 50, search, type, directoryId, uploader } = options;
        const filter: any = { isDeleted: false };

        if (directoryId !== undefined) filter.directoryId = directoryId;
        if (uploader) filter.uploader = new Types.ObjectId(uploader);
        if (search) filter.name = new RegExp(search, "i");
        if (type) filter.type = new RegExp(`^${type}/`, "i");

        const [totalItems, data] = await Promise.all([
            Media.countDocuments(filter),
            Media.find(filter)
                .sort({ createdAt: -1 })
                .skip((page - 1) * limit)
                .limit(limit),
        ]);

        return {
            data,
            pagination: { totalItems, totalPages: Math.ceil(totalItems / limit), currentPage: page, limit },
        };
    },

    async update(id: string, data: Partial<IMedia>): Promise<IMedia | null> {
        return Media.findOneAndUpdate({ _id: id, isDeleted: false }, { $set: data }, { new: true });
    },

    async softDelete(id: string): Promise<IMedia | null> {
        return Media.findOneAndUpdate({ _id: id, isDeleted: false }, { isDeleted: true }, { new: true });
    },

    async hardDelete(id: string): Promise<boolean> {
        const media = await Media.findById(id);
        if (!media) return false;
        await storageService.delete(media.mediaPath);
        await Media.deleteOne({ _id: id });
        logger.info(`[MediaService] Hard deleted: ${id}`);
        return true;
    },

    async uploadAndCreate(
        file: Express.Multer.File,
        folder: string,
        uploaderId: string,
        directoryId?: string
    ): Promise<IMedia> {
        const filename = `${Date.now()}-${uuidv4()}-${file.originalname}`;
        const resourceType = file.mimetype.startsWith("video/") ? "video" : "image";

        const result = await storageService.uploadFile(file.path, folder, filename);
        if (!result) throw new Error("Upload failed");

        return this.create({
            name: file.originalname,
            type: file.mimetype,
            mediaPath: result.path,
            size: file.size,
            directoryId,
            uploader: uploaderId,
        });
    },
};
</file>

<file path="backend/src/services/payment.service.ts">
/**
 * Payment Service (Template)
 * Implement your payment provider (Stripe, PayPal, VNPay, etc.)
 */
import { logger } from "../utils/logger.util";

export interface PaymentIntent {
    id: string;
    amount: number;
    currency: string;
    status: "pending" | "completed" | "failed" | "refunded";
    metadata?: Record<string, any>;
}

export const paymentService = {
    /**
     * Create a payment intent.
     */
    async createPayment(data: {
        amount: number;
        currency: string;
        userId: string;
        description?: string;
    }): Promise<PaymentIntent> {
        logger.info(`[Payment] Creating payment: ${data.amount} ${data.currency}`);

        // TODO: Implement with your payment provider
        // Example with Stripe:
        // const intent = await stripe.paymentIntents.create({
        //   amount: data.amount,
        //   currency: data.currency,
        //   metadata: { userId: data.userId },
        // });

        return {
            id: `pay_${Date.now()}`,
            amount: data.amount,
            currency: data.currency,
            status: "pending",
            metadata: { userId: data.userId, description: data.description },
        };
    },

    /**
     * Verify a payment.
     */
    async verifyPayment(paymentId: string): Promise<PaymentIntent | null> {
        logger.info(`[Payment] Verifying: ${paymentId}`);

        // TODO: Verify with your payment provider
        return {
            id: paymentId,
            amount: 0,
            currency: "usd",
            status: "completed",
        };
    },

    /**
     * Refund a payment.
     */
    async refund(paymentId: string, amount?: number): Promise<boolean> {
        logger.info(`[Payment] Refunding: ${paymentId}`);

        // TODO: Implement refund with your provider
        return true;
    },

    /**
     * Handle webhook from payment provider.
     */
    async handleWebhook(payload: any, signature: string): Promise<void> {
        logger.info("[Payment] Webhook received");

        // TODO: Verify signature and handle events
        // const event = stripe.webhooks.constructEvent(payload, signature, webhookSecret);
        // switch (event.type) {
        //   case 'payment_intent.succeeded':
        //     // Handle success
        //     break;
        // }
    },
};
</file>

<file path="backend/src/services/quiz.service.ts">
/**
 * Quiz Service
 * Orchestrates quiz creation, processing, and CRUD operations.
 */
import mongoose, { Types } from "mongoose";
import crypto from "crypto";
import Quiz, { IQuiz, QuizStatus } from "../models/quiz.model";
import Question from "../models/question.model";
import { driveStorage } from "../utils/storage/drive.storage";
import { addQuizProcessingJob } from "../workers/quiz.worker";
import { geminiService } from "./gemini.service";
import { NotFoundError } from "../errors";
import { logger } from "../utils/logger.util";
import { UpdateQuestionInput, QuizQueryInput } from "../types/quiz.types";
import { AnswerSource } from "../models/quiz.model";
import path from "path";
import fs from "fs/promises";
import { existsSync, createReadStream } from "fs";

export interface CreateQuizOptions {
    file: Express.Multer.File;
    title?: string;
    userId: string;
}

export interface FindQuizzesOptions extends QuizQueryInput {
    userId?: string;
}

/**
 * Calculate MD5 hash of a file using streams (non-blocking, memory efficient)
 */
async function calculateFileHashStream(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
        const hash = crypto.createHash("md5");
        const stream = createReadStream(filePath);

        stream.on("data", (chunk) => hash.update(chunk));
        stream.on("end", () => resolve(hash.digest("hex")));
        stream.on("error", (err) => reject(err));
    });
}

/**
 * Find existing file path from DB with same hash (faster than file scan)
 */
async function findDuplicateFilePath(fileHash: string): Promise<string | null> {
    const sameFileQuiz = await Quiz.findOne({ fileHash, isDeleted: false });
    if (!sameFileQuiz) return null;

    if (sameFileQuiz.documentUrl.startsWith("file://")) {
        const oldPath = sameFileQuiz.documentUrl.replace("file://", "");
        if (existsSync(oldPath)) {
            return oldPath;
        }
    }
    return null;
}

export const quizService = {
    /**
     * Create a new quiz from uploaded document
     * Implements deduplication - reuses existing files with same content
     */
    async createFromUpload(options: CreateQuizOptions): Promise<IQuiz> {
        const { file, title, userId } = options;

        // Validate file type
        const ext = path.extname(file.originalname).toLowerCase();
        const SUPPORTED_EXTENSIONS = [".pdf", ".docx", ".doc", ".txt", ".rtf", ".odt"];

        if (!SUPPORTED_EXTENSIONS.includes(ext)) {
            throw new Error(`Unsupported file type: ${ext}. Supported: ${SUPPORTED_EXTENSIONS.join(", ")}`);
        }

        // Map extension to document type (pdf or docx-like)
        const documentType = ext === ".pdf" ? "pdf" : "docx";

        // Calculate file hash for deduplication (stream-based, non-blocking)
        const fileHash = await calculateFileHashStream(file.path);

        // Check if quiz with same hash already exists (completed)
        const existingQuiz = await Quiz.findOne({
            fileHash,
            isDeleted: false,
            status: QuizStatus.Completed
        });

        if (existingQuiz) {
            // Duplicate found - delete uploaded file and return existing quiz info
            await fs.unlink(file.path).catch(() => { });
            logger.info(`[QuizService] Dedup: Quiz already exists ${existingQuiz._id}`);

            // Return special response indicating duplicate
            return {
                ...existingQuiz.toObject(),
                isDuplicate: true,
                existingQuizId: existingQuiz._id.toString(),
            } as unknown as IQuiz & { isDuplicate: boolean; existingQuizId: string };
        }

        // Check for existing file with same content (via DB - faster)
        const existingFilePath = await findDuplicateFilePath(fileHash);

        let finalPath = file.path;
        if (existingFilePath && existingFilePath !== file.path) {
            // Duplicate file found - delete new file and use existing
            await fs.unlink(file.path).catch(() => { });
            finalPath = existingFilePath;
            logger.info(`[QuizService] Dedup: Reusing existing file ${path.basename(existingFilePath)}`);
        } else {
            logger.info(`[QuizService] New unique file: ${path.basename(file.path)}`);
        }

        const documentUrl = `file://${finalPath}`;

        // Create quiz record
        const quiz = await Quiz.create({
            title: title || file.originalname.replace(ext, ""),
            documentUrl,
            documentType,
            status: QuizStatus.Pending,
            createdBy: new Types.ObjectId(userId),
            fileHash, // Store hash for future reference
        });

        // Queue background processing
        await addQuizProcessingJob({
            quizId: quiz._id.toString(),
            documentUrl,
            documentType,
        });

        logger.info(`[QuizService] Created quiz ${quiz._id} from ${file.originalname}`);

        return quiz;
    },

    /**
     * Find quiz by ID
     */
    async findById(id: string): Promise<IQuiz | null> {
        if (!mongoose.isValidObjectId(id)) {
            return null;
        }
        return Quiz.findOne({ _id: id, isDeleted: false });
    },

    /**
     * Get quiz status
     */
    async getStatus(id: string) {
        const quiz = await this.findById(id);
        if (!quiz) {
            throw new NotFoundError("Quiz not found");
        }

        return {
            quizId: quiz._id.toString(),
            status: quiz.status,
            totalQuestions: quiz.totalQuestions,
            processedQuestions: quiz.processedQuestions,
            errorMessage: quiz.errorMessage,
        };
    },

    /**
     * Find quizzes with pagination
     */
    async findAndPaginate(options: FindQuizzesOptions) {
        const { page = 1, limit = 20, status, userId } = options;
        const filter: any = { isDeleted: false };

        if (status) filter.status = status;
        if (userId) filter.createdBy = new Types.ObjectId(userId);

        const [totalItems, data] = await Promise.all([
            Quiz.countDocuments(filter),
            Quiz.find(filter)
                .select("title status totalQuestions processedQuestions sections sectionCounts createdAt documentType fileHash")
                .sort({ createdAt: -1 })
                .skip((page - 1) * limit)
                .limit(limit),
        ]);

        return {
            data,
            pagination: {
                totalItems,
                totalPages: Math.ceil(totalItems / limit),
                currentPage: page,
                limit,
            },
        };
    },

    /**
     * Update a specific question in a quiz
     */
    async updateQuestion(
        quizId: string,
        questionId: string,
        data: UpdateQuestionInput
    ): Promise<IQuiz | null> {
        const quiz = await this.findById(quizId);
        if (!quiz) {
            throw new NotFoundError("Quiz not found");
        }

        const questionIndex = quiz.questions.findIndex(
            (q) => q._id?.toString() === questionId
        );

        if (questionIndex === -1) {
            throw new NotFoundError("Question not found");
        }

        // Update question fields
        if (data.correctAnswerKey !== undefined) {
            quiz.questions[questionIndex].correctAnswerKey = data.correctAnswerKey;
        }
        if (data.explanation !== undefined) {
            quiz.questions[questionIndex].explanation = data.explanation;
        }
        if (data.source !== undefined) {
            quiz.questions[questionIndex].source = data.source;
        }

        await quiz.save();

        logger.info(`[QuizService] Updated question ${questionId} in quiz ${quizId}`);

        return quiz;
    },

    /**
     * Soft delete a quiz
     */
    async softDelete(id: string): Promise<IQuiz | null> {
        return Quiz.findOneAndUpdate(
            { _id: id, isDeleted: false },
            { isDeleted: true },
            { new: true }
        );
    },

    /**
     * Hard delete a quiz
     */
    async hardDelete(id: string): Promise<boolean> {
        const quiz = await Quiz.findById(id);
        if (!quiz) return false;

        // Delete from Google Drive
        if (quiz.documentUrl) {
            const fileId = driveStorage.extractFileId(quiz.documentUrl);
            if (fileId) {
                await driveStorage.deleteFile(fileId);
            }
        }

        await Quiz.deleteOne({ _id: id });
        logger.info(`[QuizService] Hard deleted quiz: ${id}`);

        return true;
    },

    /**
     * Generate AI explanation when user answers incorrectly
     */
    async explainWrongAnswer(
        quizId: string,
        questionId: string,
        userAnswerKey: string
    ): Promise<{ explanation: string }> {
        const quiz = await this.findById(quizId);
        if (!quiz) {
            throw new NotFoundError("Quiz not found");
        }

        const question = quiz.questions.find(function (q) {
            return q._id?.toString() === questionId;
        });

        if (!question) {
            throw new NotFoundError("Question not found");
        }

        // If user answered correctly, no need for explanation
        if (question.correctAnswerKey === userAnswerKey) {
            return { explanation: "Chúc mừng! Bạn đã trả lời đúng." };
        }

        // Gọi AI với section context để giải thích chuyên sâu hơn
        const explanation = await geminiService.generateWrongAnswerExplanation({
            questionStem: question.stem,
            choices: question.choices.map(function (c) {
                return {
                    key: c.key,
                    text: c.text,
                };
            }),
            correctAnswerKey: question.correctAnswerKey,
            userAnswerKey: userAnswerKey,
            section: question.section, // Truyền Section để AI giải thích theo ngữ cảnh
        });

        logger.info(`[QuizService] Generated explanation for question ${questionId}`);

        return { explanation };
    },

    /**
     * Debug parse file and return raw JSON (no database save)
     */
    async debugParseFile(file: Express.Multer.File) {
        const uploadsDir = path.join(__dirname, "..", "..", "uploads", "documents");

        const { documentService } = await import("./document.service");

        const ext = path.extname(file.originalname).toLowerCase();
        let parsed;

        if (ext === ".pdf") {
            parsed = await documentService.parsePdf(file.path);
        } else if (ext === ".docx") {
            parsed = await documentService.parseDocx(file.path);
        } else {
            throw new Error("Unsupported file type");
        }

        // Clean up file after parsing
        if (existsSync(file.path)) {
            await fs.unlink(file.path);
        }

        // Format output for debugging
        const debugOutput = {
            fileName: file.originalname,
            title: parsed.title,
            totalQuestions: parsed.questions.length,
            questionsWithAnswer: parsed.questions.filter(function (q) {
                return q.correctAnswerKey;
            }).length,
            questionsNeedAI: parsed.questions.filter(function (q) {
                return !q.correctAnswerKey;
            }).length,
            questions: parsed.questions.map(function (q, idx) {
                return {
                    index: idx + 1,
                    stem: q.stem.substring(0, 150) + (q.stem.length > 150 ? "..." : ""),
                    fullStem: q.stem,
                    choices: q.choices.map(function (c) {
                        return {
                            key: c.key,
                            text: c.text.substring(0, 100) + (c.text.length > 100 ? "..." : ""),
                            fullText: c.text,
                            isMarked: c.isVisuallyMarked,
                        };
                    }),
                    correctAnswerKey: q.correctAnswerKey || "(cần AI)",
                    source: q.source,
                    choiceCount: q.choices.length,
                    hasIssue: q.choices.length < 2 || q.choices.length > 6,
                };
            }),
        };

        // Also save to file for easier viewing
        const debugFilePath = path.join(uploadsDir, `debug_${Date.now()}.json`);
        await fs.writeFile(debugFilePath, JSON.stringify(debugOutput, null, 2), "utf-8");

        return {
            ...debugOutput,
            debugFileSaved: debugFilePath,
        };
    },
};
</file>

<file path="backend/src/types/ai.types.ts">
/**
 * AI Types & Interfaces
 * Type-safe definitions for the 5-layer AI fallback system.
 */

// ==================== Input Types ====================

export interface QuestionInput {
    index: number;
    stem: string;
    choices: ChoiceInput[];
    section?: string;
}

export interface ChoiceInput {
    key: string;    // A, B, C, D
    text: string;
}

// ==================== Output Types ====================

export interface AIResponse {
    index: number;
    correctKey: string;         // A, B, C, D
    explanation?: string;
    confidence?: number;        // 0-1
    tokensUsed?: number;
}

export interface BatchResult {
    responses: AIResponse[];
    provider: AIProviderName;
    tokensUsed: number;
    duration: number;           // ms
    questionsAnswered: number;
    questionsFailed: number;
}

// ==================== Provider Types ====================

export type AIProviderName =
    | "Gemini"
    | "GitHub"
    | "Groq"
    | "HuggingFace"
    | "Ollama"
    | "Cache";

export interface AIProviderConfig {
    name: AIProviderName;
    priority: number;           // Lower = higher priority
    maxBatchSize: number;
    isEnabled: boolean;
    apiKeys?: string[];         // For rotation
}

export interface AIProvider {
    name: AIProviderName;
    priority: number;

    /**
     * Check if provider is available (API key set, not rate limited)
     */
    isAvailable(): Promise<boolean>;

    /**
     * Solve a batch of questions
     */
    solveBatch(questions: QuestionInput[]): Promise<BatchResult>;

    /**
     * Get current rate limit status
     */
    getRateLimitStatus?(): { remaining: number; resetAt: Date };
}

// ==================== Cache Types ====================

export interface CacheCheckResult {
    hit: boolean;
    response?: AIResponse;
    provider?: "Cache";
}

// ==================== Error Types ====================

export interface AIError {
    provider: AIProviderName;
    code: AIErrorCode;
    message: string;
    retryAfter?: number;        // seconds
}

export type AIErrorCode =
    | "RATE_LIMITED"            // 429
    | "QUOTA_EXCEEDED"          // API quota exhausted
    | "NETWORK_ERROR"           // Connection issues
    | "INVALID_RESPONSE"        // Unparseable AI response
    | "PROVIDER_UNAVAILABLE"    // API key missing or invalid
    | "UNKNOWN";

// ==================== Orchestrator Types ====================

export interface OrchestratorResult {
    responses: AIResponse[];
    providersUsed: AIProviderName[];
    totalTokens: number;
    cacheHits: number;
    cacheMisses: number;
    failedQuestions: number;
    duration: number;
}

export interface OrchestratorOptions {
    maxRetries?: number;
    retryDelayMs?: number;
    enableCache?: boolean;
    preferredProvider?: AIProviderName;
}

// ==================== Token Optimization ====================

export interface TokenStats {
    inputTokens: number;
    outputTokens: number;
    savedByCache: number;
    savedByPruning: number;
}

/**
 * Prune text to reduce token consumption
 * - Remove extra whitespace
 * - Truncate long texts
 * - Remove filler words
 */
export function pruneText(text: string, maxLength: number = 500): string {
    return text
        .replace(/\s+/g, " ")           // Collapse whitespace
        .replace(/\.\.\./g, "…")        // Unicode ellipsis
        .trim()
        .substring(0, maxLength);
}

/**
 * Estimate token count (rough approximation)
 * Vietnamese ~1.5 tokens per word, English ~1.3
 */
export function estimateTokens(text: string): number {
    const words = text.split(/\s+/).length;
    return Math.ceil(words * 1.5);
}
</file>

<file path="backend/src/types/auth.types.ts">
/**
 * Auth Schemas & Types
 */
import { z } from "zod";

export const registerSchema = z.object({
    username: z.string().min(3).max(30),
    email: z.string().email(),
    password: z.string().min(8),
    fullName: z.string().min(2).optional(),
});

export const loginSchema = z.object({
    email: z.string().email(),
    password: z.string().min(1),
});

export type RegisterInput = z.infer<typeof registerSchema>;
export type LoginInput = z.infer<typeof loginSchema>;
</file>

<file path="backend/src/types/feedback.types.ts">
/**
 * Feedback Schemas & Types
 */
import { z } from "zod";

export const createFeedbackSchema = z.object({
    referenceId: z.string().optional(),
    referenceType: z.string().optional(),
    content: z.string().min(1).max(2000),
    rating: z.number().min(1).max(5).optional(),
});

export type CreateFeedbackInput = z.infer<typeof createFeedbackSchema>;
</file>

<file path="backend/src/types/global.types.ts">
/**
 * Global Type Definitions
 */

// Pagination
export interface PaginationMeta {
    total: number;
    page: number;
    limit: number;
    pages: number;
}

export interface PaginatedResponse<T> {
    data: T[];
    pagination: PaginationMeta;
}

// API Response
export interface ApiResponse<T = any> {
    success: boolean;
    data?: T;
    message?: string;
    errors?: { message: string; field?: string }[];
}

// User roles
export type UserRole = "user" | "admin" | "moderator";

// Subscription types
export type SubscriptionStatus = "active" | "canceled" | "past_due" | "unpaid" | "trialing" | "pending_approval" | "expired";
export type BillingPeriod = "monthly" | "yearly";
export type PaymentProvider = "stripe" | "paypal" | "momo" | "vnpay";
export type TransactionStatus = "pending" | "completed" | "failed" | "refunded";

// Feedback
export type FeedbackStatus = "pending_review" | "approved" | "rejected";

// Media
export type MediaType = "image" | "video" | "document";
export type StorageMode = "local" | "cloud";

export interface UploadedFile {
    url: string;
    path: string;
    filename?: string;
    publicId?: string;
    size?: number;
    mimetype?: string;
}

// Common
export type ObjectId = string;

export interface Timestamps {
    createdAt: Date;
    updatedAt: Date;
}

export interface SoftDeletable {
    isDeleted: boolean;
}
</file>

<file path="backend/src/types/index.ts">
/**
 * Types Barrel Export
 */

// Express type extensions (side effect import)
import "./express/index.d";

// Global types
export * from "./global.types";

// Validation schemas
export * from "./zod";
</file>

<file path="backend/src/types/product.types.ts">
/**
 * Product Schemas & Types
 */
import { z } from "zod";

export const createProductSchema = z.object({
    name: z.string().min(1).max(200),
    description: z.string().min(1),
    price: z.number().min(0),
    stock: z.number().min(0).optional(),
    category: z.string().optional(),
    images: z.array(z.string()).optional(),
});

export type CreateProductInput = z.infer<typeof createProductSchema>;
</file>

<file path="backend/src/types/quiz.types.ts">
/**
 * Quiz Types
 * TypeScript interfaces and Zod validation schemas for Quiz API.
 */
import { z } from "zod";
import { AnswerSource, QuizStatus } from "../models/quiz.model";

// ==================== DTOs ====================

export interface QuizUploadResponse {
    quizId: string;
    message: string;
    status: QuizStatus;
}

export interface QuizStatusResponse {
    quizId: string;
    status: QuizStatus;
    totalQuestions: number;
    processedQuestions: number;
    errorMessage?: string;
}

export interface ChoiceDTO {
    key: string;
    text: string;
    isVisuallyMarked: boolean;
}

export interface QuestionDTO {
    id: string;
    stem: string;
    choices: ChoiceDTO[];
    correctAnswerKey: string;
    explanation?: string;
    source: AnswerSource;
}

export interface QuizDTO {
    id: string;
    title: string;
    documentUrl: string;
    documentType: "pdf" | "docx";
    status: QuizStatus;
    questions: QuestionDTO[];
    totalQuestions: number;
    processedQuestions: number;
    createdAt: string;
    updatedAt: string;
}

// ==================== Parsed Document Types ====================

export interface ParsedChoice {
    key: string;
    text: string;
    isVisuallyMarked: boolean;
}

export interface ParsedQuestion {
    index?: number;
    stem: string;
    choices: ParsedChoice[];
    correctAnswerKey: string;
    source: AnswerSource;
    section?: string; // Sticky Section support
}

export interface ParsedDocument {
    title: string;
    questions: ParsedQuestion[];
}

// ==================== AI Response Types ====================

export interface GeminiAnswerResponse {
    correct_key: string;
    explanation: string;
}

// ==================== Job Queue Types ====================

export interface QuizProcessingJob {
    quizId: string;
    documentUrl: string;
    documentType: "pdf" | "docx";
}

// ==================== Zod Validation Schemas ====================

export const updateQuestionSchema = z.object({
    correctAnswerKey: z.string().min(1).max(1).optional(),
    explanation: z.string().max(2000).optional(),
    source: z.nativeEnum(AnswerSource).optional(),
});

export const quizQuerySchema = z.object({
    page: z.coerce.number().min(1).default(1),
    limit: z.coerce.number().min(1).max(100).default(20),
    status: z.nativeEnum(QuizStatus).optional(),
});

export type UpdateQuestionInput = z.infer<typeof updateQuestionSchema>;
export type QuizQueryInput = z.infer<typeof quizQuerySchema>;
</file>

<file path="backend/src/types/zod/auth.schema.ts">
/**
 * Auth Schemas
 */
import { z } from "zod";

export const registerSchema = z.object({
    username: z.string().min(3).max(30).regex(/^[a-z0-9_]+$/i, "Username can only contain letters, numbers, and underscores"),
    email: z.string().email("Invalid email address"),
    password: z.string().min(8, "Password must be at least 8 characters"),
    fullName: z.string().min(2).optional(),
});

export const loginSchema = z.object({
    email: z.string().email(),
    password: z.string().min(1, "Password is required"),
});

export const verifyEmailSchema = z.object({
    email: z.string().email(),
    otp: z.string().length(6, "OTP must be 6 digits"),
});

export const forgotPasswordSchema = z.object({
    email: z.string().email(),
});

export const resetPasswordSchema = z.object({
    email: z.string().email(),
    otp: z.string().length(6),
    newPassword: z.string().min(8),
});

export const changePasswordSchema = z.object({
    currentPassword: z.string().min(1),
    newPassword: z.string().min(8),
});

export type RegisterInput = z.infer<typeof registerSchema>;
export type LoginInput = z.infer<typeof loginSchema>;
</file>

<file path="backend/src/types/zod/common.schema.ts">
/**
 * Common Schemas
 */
import { z } from "zod";

export const paginationSchema = z.object({
    page: z.string().regex(/^\d+$/).transform(Number).optional(),
    limit: z.string().regex(/^\d+$/).transform(Number).optional(),
});

export const objectIdSchema = z.object({
    id: z.string().regex(/^[a-f\d]{24}$/i, "Invalid ID format"),
});

export const dateRangeSchema = z.object({
    startDate: z.string().datetime().optional(),
    endDate: z.string().datetime().optional(),
});

export type PaginationInput = z.infer<typeof paginationSchema>;
</file>

<file path="backend/src/types/zod/feedback.schema.ts">
/**
 * Feedback Schemas
 */
import { z } from "zod";

export const createFeedbackSchema = z.object({
    referenceId: z.string().optional(),
    referenceType: z.string().optional(),
    content: z.string().min(1).max(2000),
    rating: z.number().min(1).max(5).optional(),
});

export const updateFeedbackSchema = z.object({
    content: z.string().min(1).max(2000).optional(),
    rating: z.number().min(1).max(5).optional(),
});

export type CreateFeedbackInput = z.infer<typeof createFeedbackSchema>;
export type UpdateFeedbackInput = z.infer<typeof updateFeedbackSchema>;
</file>

<file path="backend/src/types/zod/index.ts">
/**
 * Zod Schemas Barrel Export
 */
export * from "./auth.schema";
export * from "./product.schema";
export * from "./feedback.schema";
export * from "./media.schema";
export * from "./common.schema";
</file>

<file path="backend/src/types/zod/media.schema.ts">
/**
 * Media Schemas
 */
import { z } from "zod";

export const updateMediaSchema = z.object({
    name: z.string().min(1).max(255).optional(),
    tags: z.array(z.string()).optional(),
});

export const createDirectorySchema = z.object({
    name: z.string().min(1).max(100),
    parentId: z.string().optional(),
});

export type UpdateMediaInput = z.infer<typeof updateMediaSchema>;
export type CreateDirectoryInput = z.infer<typeof createDirectorySchema>;
</file>

<file path="backend/src/types/zod/product.schema.ts">
/**
 * Product Schemas
 */
import { z } from "zod";

export const createProductSchema = z.object({
    name: z.string().min(1).max(200),
    description: z.string().min(1),
    price: z.number().min(0),
    stock: z.number().min(0).optional(),
    category: z.string().optional(),
    images: z.array(z.string().url()).optional(),
});

export const updateProductSchema = createProductSchema.partial();

export type CreateProductInput = z.infer<typeof createProductSchema>;
export type UpdateProductInput = z.infer<typeof updateProductSchema>;
</file>

<file path="backend/src/utils/fileValidation.util.ts">
/**
 * File Validation Utility
 * Deep validation of uploaded files using file-type library.
 * Prevents polyglot attacks and ensures file integrity.
 */
import { logger } from "./logger.util";

// Dynamic import for file-type (ESM module)
let fileTypeFromBuffer: ((buffer: Buffer) => Promise<{ ext: string; mime: string } | undefined>) | null = null;

// Initialize file-type dynamically
async function initFileType() {
    try {
        const fileType = await import("file-type");
        // file-type v16+ exports fromBuffer
        fileTypeFromBuffer = fileType.fromBuffer || fileType.default?.fromBuffer;
    } catch {
        logger.warn("[FileValidation] file-type not available, using fallback");
    }
}
initFileType();

// Allowed MIME types for document upload
const ALLOWED_DOCUMENT_TYPES: Record<string, string[]> = {
    pdf: ["application/pdf"],
    docx: [
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/zip", // DOCX is actually a ZIP file
    ],
};

// Magic bytes for quick validation
const MAGIC_BYTES = {
    pdf: Buffer.from([0x25, 0x50, 0x44, 0x46]), // %PDF
    docx: Buffer.from([0x50, 0x4b, 0x03, 0x04]), // PK.. (ZIP header)
};

export interface FileValidationResult {
    isValid: boolean;
    detectedType: string | null;
    detectedMime: string | null;
    error?: string;
}

/**
 * Validate file buffer using deep inspection
 */
export async function validateFileBuffer(
    buffer: Buffer,
    expectedType: "pdf" | "docx"
): Promise<FileValidationResult> {
    try {
        // 1. Quick magic bytes check
        const magicBytes = MAGIC_BYTES[expectedType];
        if (!buffer.subarray(0, magicBytes.length).equals(magicBytes)) {
            return {
                isValid: false,
                detectedType: null,
                detectedMime: null,
                error: `Invalid file header. Expected ${expectedType.toUpperCase()} magic bytes.`,
            };
        }

        // 2. Deep file type detection (if available)
        if (fileTypeFromBuffer) {
            const detected = await fileTypeFromBuffer(buffer);

            if (!detected) {
                // Magic bytes matched but file-type couldn't identify - allow it
                return {
                    isValid: true,
                    detectedType: expectedType,
                    detectedMime: null,
                };
            }

            // 3. Check against allowed types
            const allowedMimes = ALLOWED_DOCUMENT_TYPES[expectedType];
            const isAllowed = allowedMimes.includes(detected.mime);

            if (!isAllowed) {
                logger.warn(
                    `[FileValidation] Rejected file: expected ${expectedType}, got ${detected.ext} (${detected.mime})`
                );
                return {
                    isValid: false,
                    detectedType: detected.ext,
                    detectedMime: detected.mime,
                    error: `Invalid file type. Expected ${expectedType}, got ${detected.ext}`,
                };
            }

            logger.info(`[FileValidation] Validated ${expectedType}: ${detected.mime}`);

            return {
                isValid: true,
                detectedType: detected.ext,
                detectedMime: detected.mime,
            };
        }

        // Fallback: Magic bytes matched, allow
        return {
            isValid: true,
            detectedType: expectedType,
            detectedMime: null,
        };
    } catch (error: any) {
        logger.error(`[FileValidation] Error:`, error);
        return {
            isValid: false,
            detectedType: null,
            detectedMime: null,
            error: error.message || "File validation failed",
        };
    }
}

/**
 * Quick file extension check (for use before buffer is available)
 */
export function isAllowedExtension(filename: string): boolean {
    const ext = filename.toLowerCase().split(".").pop();
    return ext === "pdf" || ext === "docx";
}

/**
 * Get expected type from filename
 */
export function getExpectedType(filename: string): "pdf" | "docx" | null {
    const ext = filename.toLowerCase().split(".").pop();
    if (ext === "pdf") return "pdf";
    if (ext === "docx") return "docx";
    return null;
}
</file>

<file path="backend/src/utils/fileValidator.util.ts">
/**
 * File Validator Utility
 * Validates file types using magic bytes (file signatures)
 */
import fs from "fs";
import { logger } from "./logger.util";

// Magic byte signatures for supported file types
const FILE_SIGNATURES: Record<string, { signature: Buffer; offset: number }[]> = {
    // PDF: starts with %PDF
    "application/pdf": [
        { signature: Buffer.from([0x25, 0x50, 0x44, 0x46]), offset: 0 }, // %PDF
    ],
    // DOCX is a ZIP file, starts with PK (0x50 0x4B)
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
        { signature: Buffer.from([0x50, 0x4B, 0x03, 0x04]), offset: 0 }, // PK..
        { signature: Buffer.from([0x50, 0x4B, 0x05, 0x06]), offset: 0 }, // Empty archive
        { signature: Buffer.from([0x50, 0x4B, 0x07, 0x08]), offset: 0 }, // Spanned archive
    ],
};

export interface FileValidationResult {
    isValid: boolean;
    detectedType: string | null;
    error?: string;
}

/**
 * Validate file by checking magic bytes
 * @param filePath Path to the file
 * @param expectedMimeType Expected MIME type
 * @returns Validation result
 */
export function validateFileMagicBytes(
    filePath: string,
    expectedMimeType: string
): FileValidationResult {
    try {
        // Read first 8 bytes (enough for our signatures)
        const fd = fs.openSync(filePath, "r");
        const buffer = Buffer.alloc(8);
        fs.readSync(fd, buffer, 0, 8, 0);
        fs.closeSync(fd);

        const signatures = FILE_SIGNATURES[expectedMimeType];
        if (!signatures) {
            logger.warn(`[FileValidator] No signature defined for: ${expectedMimeType}`);
            return { isValid: true, detectedType: expectedMimeType };
        }

        // Check if file matches any valid signature
        for (const { signature, offset } of signatures) {
            const fileSlice = buffer.subarray(offset, offset + signature.length);
            if (fileSlice.equals(signature)) {
                logger.info(`[FileValidator] Valid ${expectedMimeType} file detected`);
                return { isValid: true, detectedType: expectedMimeType };
            }
        }

        // File doesn't match expected signature
        const detectedType = detectFileType(buffer);
        logger.warn(
            `[FileValidator] Magic bytes mismatch! Expected: ${expectedMimeType}, Detected: ${detectedType}`
        );

        return {
            isValid: false,
            detectedType,
            error: `File content does not match expected type. Expected ${expectedMimeType}, detected ${detectedType || "unknown"}`,
        };
    } catch (error) {
        logger.error("[FileValidator] Error reading file:", error);
        return {
            isValid: false,
            detectedType: null,
            error: "Failed to validate file",
        };
    }
}

/**
 * Detect file type from magic bytes
 */
function detectFileType(buffer: Buffer): string | null {
    for (const [mimeType, signatures] of Object.entries(FILE_SIGNATURES)) {
        for (const { signature, offset } of signatures) {
            const fileSlice = buffer.subarray(offset, offset + signature.length);
            if (fileSlice.equals(signature)) {
                return mimeType;
            }
        }
    }

    // Check for common dangerous file types
    const hex = buffer.toString("hex").slice(0, 8);

    // EXE files
    if (hex.startsWith("4d5a")) {
        return "application/x-executable";
    }
    // ELF (Linux executable)
    if (hex.startsWith("7f454c46")) {
        return "application/x-elf";
    }
    // Script files with shebang
    if (buffer.toString("utf8", 0, 2) === "#!") {
        return "text/x-script";
    }

    return null;
}

/**
 * Check if file type could be dangerous
 */
export function isDangerousFileType(detectedType: string | null): boolean {
    const dangerousTypes = [
        "application/x-executable",
        "application/x-elf",
        "text/x-script",
        "application/x-msdownload",
    ];

    return detectedType !== null && dangerousTypes.includes(detectedType);
}
</file>

<file path="backend/src/utils/logger.util.ts">
/**
 * Winston Logger Utility
 */
import winston from "winston";

const logFormat = winston.format.combine(
    winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
    winston.format.printf(({ timestamp, level, message, ...meta }) => {
        let msg = `${timestamp} [${level.toUpperCase()}]: ${message}`;
        if (Object.keys(meta).length > 0) {
            msg += ` ${JSON.stringify(meta)}`;
        }
        return msg;
    })
);

export const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || "info",
    format: logFormat,
    transports: [
        new winston.transports.Console({
            format: winston.format.combine(winston.format.colorize(), logFormat),
        }),
        // Add file transport in production
        ...(process.env.NODE_ENV === "production"
            ? [
                new winston.transports.File({ filename: "logs/error.log", level: "error" }),
                new winston.transports.File({ filename: "logs/combined.log" }),
            ]
            : []),
    ],
});
</file>

<file path="backend/src/utils/redis.util.ts">
/**
 * Redis Utility
 */
import { createClient, RedisClientType } from "redis";
import { logger } from "./logger.util";

let redisClient: RedisClientType | null = null;

async function initRedis(): Promise<void> {
    const redisUrl = process.env.REDIS_URL;
    if (!redisUrl) {
        logger.warn("[Redis] REDIS_URL not set - Redis features disabled");
        return;
    }

    try {
        redisClient = createClient({ url: redisUrl });
        redisClient.on("error", (err) => logger.error("[Redis] Error:", err));
        await redisClient.connect();
        logger.info("[Redis] Connected");
    } catch (error) {
        logger.error("[Redis] Connection failed:", error);
        redisClient = null;
    }
}

initRedis();

export async function getFromCache(key: string): Promise<string | null> {
    if (!redisClient) return null;
    return redisClient.get(key);
}

export async function setInCache(key: string, value: string, expiresIn?: number): Promise<void> {
    if (!redisClient) return;
    if (expiresIn) {
        await redisClient.setEx(key, expiresIn, value);
    } else {
        await redisClient.set(key, value);
    }
}

export async function deleteFromCache(key: string): Promise<void> {
    if (!redisClient) return;
    await redisClient.del(key);
}

export { redisClient };
</file>

<file path="backend/src/utils/scheduler.util.ts">
/**
 * Scheduler Utility
 */
import cron from "node-cron";
import { logger } from "./logger.util";

interface ScheduledJob {
    name: string;
    task: cron.ScheduledTask;
}

const scheduledJobs: ScheduledJob[] = [];

export function registerSchedule(name: string, cronExpression: string, callback: () => void): void {
    const task = cron.schedule(cronExpression, callback, { scheduled: false });
    scheduledJobs.push({ name, task });
    logger.info(`[Scheduler] Registered: ${name} (${cronExpression})`);
}

export function startSchedulers(): void {
    scheduledJobs.forEach(({ name, task }) => {
        task.start();
        logger.info(`[Scheduler] Started: ${name}`);
    });
}

export function stopSchedulers(): void {
    scheduledJobs.forEach(({ name, task }) => {
        task.stop();
        logger.info(`[Scheduler] Stopped: ${name}`);
    });
}

// ===== Example Scheduled Tasks =====
// Clean up expired sessions every day at 3 AM
registerSchedule("cleanupSessions", "0 3 * * *", async () => {
    logger.info("[Scheduler] Running session cleanup...");
    // TODO: Add cleanup logic here
});
</file>

<file path="backend/src/utils/storage/drive.storage.ts">
/**
 * Google Drive Storage
 * Handles file uploads and downloads from Google Drive.
 */
import { google } from "googleapis";
import { Readable } from "stream";
import path from "path";
import fs from "fs";
import { logger } from "../logger.util";

// Google Drive API setup
function getDriveClient() {
    const auth = new google.auth.GoogleAuth({
        credentials: {
            client_email: process.env.GOOGLE_DRIVE_CLIENT_EMAIL,
            private_key: process.env.GOOGLE_DRIVE_PRIVATE_KEY?.replace(/\\n/g, "\n"),
        },
        scopes: ["https://www.googleapis.com/auth/drive.file"],
    });

    return google.drive({ version: "v3", auth });
}

export const driveStorage = {
    /**
     * Upload a file to Google Drive
     */
    async uploadFile(
        filePath: string,
        fileName: string,
        mimeType: string
    ): Promise<{ fileId: string; webViewLink: string }> {
        const drive = getDriveClient();
        const folderId = process.env.GOOGLE_DRIVE_FOLDER_ID;

        const fileMetadata: any = {
            name: fileName,
        };

        if (folderId) {
            fileMetadata.parents = [folderId];
        }

        const media = {
            mimeType,
            body: fs.createReadStream(filePath),
        };

        try {
            const response = await drive.files.create({
                requestBody: fileMetadata,
                media,
                fields: "id, webViewLink",
            });

            const fileId = response.data.id!;

            // Make file accessible via link
            await drive.permissions.create({
                fileId,
                requestBody: {
                    role: "reader",
                    type: "anyone",
                },
            });

            // Get the updated webViewLink
            const file = await drive.files.get({
                fileId,
                fields: "webViewLink",
            });

            logger.info(`[DriveStorage] Uploaded file: ${fileName}, ID: ${fileId}`);

            return {
                fileId,
                webViewLink: file.data.webViewLink || `https://drive.google.com/file/d/${fileId}/view`,
            };
        } catch (error) {
            logger.error(`[DriveStorage] Upload failed:`, error);
            throw error;
        }
    },

    /**
     * Download a file from Google Drive to local temp directory
     */
    async downloadFile(fileId: string, destPath: string): Promise<string> {
        const drive = getDriveClient();

        try {
            const response = await drive.files.get(
                { fileId, alt: "media" },
                { responseType: "stream" }
            );

            const destDir = path.dirname(destPath);
            if (!fs.existsSync(destDir)) {
                fs.mkdirSync(destDir, { recursive: true });
            }

            const dest = fs.createWriteStream(destPath);

            return new Promise((resolve, reject) => {
                (response.data as Readable)
                    .on("end", () => {
                        logger.info(`[DriveStorage] Downloaded file to: ${destPath}`);
                        resolve(destPath);
                    })
                    .on("error", (err: Error) => {
                        logger.error(`[DriveStorage] Download failed:`, err);
                        reject(err);
                    })
                    .pipe(dest);
            });
        } catch (error) {
            logger.error(`[DriveStorage] Download failed:`, error);
            throw error;
        }
    },

    /**
     * Delete a file from Google Drive
     */
    async deleteFile(fileId: string): Promise<boolean> {
        const drive = getDriveClient();

        try {
            await drive.files.delete({ fileId });
            logger.info(`[DriveStorage] Deleted file: ${fileId}`);
            return true;
        } catch (error) {
            logger.error(`[DriveStorage] Delete failed:`, error);
            return false;
        }
    },

    /**
     * Extract file ID from Google Drive URL
     */
    extractFileId(url: string): string | null {
        const patterns = [
            /\/file\/d\/([a-zA-Z0-9_-]+)/,
            /id=([a-zA-Z0-9_-]+)/,
            /^([a-zA-Z0-9_-]+)$/,
        ];

        for (const pattern of patterns) {
            const match = url.match(pattern);
            if (match) return match[1];
        }

        return null;
    },
};
</file>

<file path="backend/src/utils/storage/index.ts">
/**
 * Unified Storage Service
 * Local storage for media files. Documents are stored on Google Drive.
 */
import { localStorageService, UploadResult } from "./local.storage";
import { logger } from "../logger.util";

export interface UnifiedUploadResult {
    url: string;
    path: string;
    filename?: string;
}

class StorageService {
    constructor() {
        logger.info("[Storage] Using local storage mode");
    }

    async upload(
        buffer: Buffer,
        folder: string,
        filename: string
    ): Promise<UnifiedUploadResult> {
        const result = await localStorageService.uploadBuffer(buffer, folder, filename);
        return { url: result.url, path: result.path, filename: result.filename };
    }

    async uploadFile(
        filePath: string,
        folder: string,
        filename: string
    ): Promise<UnifiedUploadResult> {
        const result = await localStorageService.uploadFile(filePath, folder, filename);
        return { url: result.url, path: result.path, filename: result.filename };
    }

    async delete(path: string): Promise<boolean> {
        return localStorageService.delete(path);
    }

    getUrl(path: string): string {
        return localStorageService.getUrl(path);
    }
}

export const storageService = new StorageService();
export { localStorageService } from "./local.storage";
</file>

<file path="backend/src/utils/storage/local.storage.ts">
/**
 * Local Storage Service
 * Disk-based file storage for development or self-hosted servers.
 */
import fs from "fs/promises";
import path from "path";
import { logger } from "../logger.util";

const UPLOADS_DIR = process.env.UPLOADS_DIR || path.join(process.cwd(), "uploads");

export interface UploadResult {
    url: string;
    path: string;
    filename: string;
    mimetype: string;
    size: number;
}

class LocalStorageService {
    private baseUrl: string;
    private uploadsPath: string;

    constructor() {
        this.baseUrl = process.env.BASE_URL || "http://localhost:5000";
        this.uploadsPath = UPLOADS_DIR;
        this.ensureDirectoryExists(this.uploadsPath);
    }

    private async ensureDirectoryExists(dirPath: string): Promise<void> {
        try {
            await fs.mkdir(dirPath, { recursive: true });
        } catch { }
    }

    async uploadBuffer(buffer: Buffer, folder: string, filename: string): Promise<UploadResult> {
        const folderPath = path.join(this.uploadsPath, folder);
        await this.ensureDirectoryExists(folderPath);

        const filePath = path.join(folderPath, filename);
        await fs.writeFile(filePath, buffer);

        const relativePath = path.join("uploads", folder, filename).replace(/\\/g, "/");
        const url = `${this.baseUrl}/${relativePath}`;

        logger.info(`[LocalStorage] Uploaded: ${relativePath}`);
        return {
            url,
            path: relativePath,
            filename,
            mimetype: this.getMimeType(filename),
            size: buffer.length,
        };
    }

    async uploadFile(tempPath: string, folder: string, filename: string): Promise<UploadResult> {
        const buffer = await fs.readFile(tempPath);
        const result = await this.uploadBuffer(buffer, folder, filename);
        try {
            await fs.unlink(tempPath);
        } catch { }
        return result;
    }

    async delete(filePath: string): Promise<boolean> {
        try {
            const fullPath = path.join(process.cwd(), filePath);
            await fs.unlink(fullPath);
            logger.info(`[LocalStorage] Deleted: ${filePath}`);
            return true;
        } catch {
            return false;
        }
    }

    getUrl(relativePath: string): string {
        return `${this.baseUrl}/${relativePath}`;
    }

    private getMimeType(filename: string): string {
        const ext = path.extname(filename).toLowerCase();
        const mimeTypes: Record<string, string> = {
            ".jpg": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".png": "image/png",
            ".gif": "image/gif",
            ".webp": "image/webp",
            ".mp4": "video/mp4",
            ".pdf": "application/pdf",
        };
        return mimeTypes[ext] || "application/octet-stream";
    }
}

export const localStorageService = new LocalStorageService();
</file>

<file path="backend/src/views/auth/login.ejs">
<div class="min-h-[80vh] flex items-center justify-center gradient-bg py-12">
    <div class="max-w-md w-full mx-4">
        <div class="bg-white rounded-2xl shadow-2xl p-8">
            <!-- Header -->
            <div class="text-center mb-8">
                <div
                    class="w-16 h-16 mx-auto bg-gradient-to-r from-purple-500 to-indigo-500 rounded-2xl flex items-center justify-center mb-4">
                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1">
                        </path>
                    </svg>
                </div>
                <h1 class="text-2xl font-bold text-gray-900">Đăng nhập</h1>
                <p class="text-gray-600 mt-2">Chào mừng bạn trở lại!</p>
            </div>

            <!-- Error Message -->
            <% if (typeof error !=='undefined' && error) { %>
                <div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6 flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <%= error %>
                </div>
                <% } %>

                    <!-- Login Form -->
                    <form id="loginForm" class="space-y-6">
                        <div>
                            <label for="email" class="block text-sm font-medium text-gray-700 mb-2">Email hoặc Tên đăng
                                nhập</label>
                            <input type="text" id="email" name="email" required
                                class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                                placeholder="email hoặc username">
                        </div>

                        <div>
                            <label for="password" class="block text-sm font-medium text-gray-700 mb-2">Mật khẩu</label>
                            <div class="relative">
                                <input type="password" id="password" name="password" required
                                    class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                                    placeholder="••••••••">
                                <button type="button" id="togglePassword"
                                    class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z">
                                        </path>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="flex items-center justify-between">
                            <label class="flex items-center">
                                <input type="checkbox"
                                    class="w-4 h-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500">
                                <span class="ml-2 text-sm text-gray-600">Ghi nhớ đăng nhập</span>
                            </label>
                            <a href="#" class="text-sm text-purple-600 hover:text-purple-700">Quên mật khẩu?</a>
                        </div>

                        <button type="submit" id="submitBtn"
                            class="w-full py-3 px-4 btn-gradient text-white font-medium rounded-lg transition-all flex items-center justify-center">
                            <span id="btnText">Đăng nhập</span>
                            <svg id="btnSpinner" class="hidden w-5 h-5 ml-2 animate-spin" fill="none"
                                viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                    stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor"
                                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                </path>
                            </svg>
                        </button>
                    </form>

                    <!-- Register Link -->
                    <div class="mt-8 text-center">
                        <p class="text-gray-600">
                            Chưa có tài khoản?
                            <a href="/register" class="text-purple-600 hover:text-purple-700 font-medium">Đăng ký
                                ngay</a>
                        </p>
                    </div>
        </div>
    </div>
</div>

<script>
    // Toggle password visibility
    document.getElementById('togglePassword').addEventListener('click', function () {
        const password = document.getElementById('password');
        password.type = password.type === 'password' ? 'text' : 'password';
    });

    // Form submission
    document.getElementById('loginForm').addEventListener('submit', async function (e) {
        e.preventDefault();

        const btn = document.getElementById('submitBtn');
        const btnText = document.getElementById('btnText');
        const btnSpinner = document.getElementById('btnSpinner');

        btn.disabled = true;
        btnText.textContent = 'Đang đăng nhập...';
        btnSpinner.classList.remove('hidden');

        try {
            const response = await fetch('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include', // CRITICAL: allows browser to save HttpOnly cookies
                body: JSON.stringify({
                    email: document.getElementById('email').value,
                    password: document.getElementById('password').value
                })
            });

            const data = await response.json();

            if (data.success) {
                // Use authManager for secure in-memory token storage
                if (window.authManager) {
                    window.authManager.setTokens(data.tokens.accessToken);
                }
                window.location.href = '/dashboard';
            } else {
                alert(data.error || 'Đăng nhập thất bại');
            }
        } catch (error) {
            alert('Có lỗi xảy ra. Vui lòng thử lại.');
        } finally {
            btn.disabled = false;
            btnText.textContent = 'Đăng nhập';
            btnSpinner.classList.add('hidden');
        }
    });
</script>
</file>

<file path="backend/src/views/auth/register.ejs">
<div class="min-h-[80vh] flex items-center justify-center gradient-bg py-12">
    <div class="max-w-md w-full mx-4">
        <div class="bg-white rounded-2xl shadow-2xl p-8">
            <!-- Header -->
            <div class="text-center mb-8">
                <div
                    class="w-16 h-16 mx-auto bg-gradient-to-r from-purple-500 to-indigo-500 rounded-2xl flex items-center justify-center mb-4">
                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z">
                        </path>
                    </svg>
                </div>
                <h1 class="text-2xl font-bold text-gray-900">Tạo tài khoản</h1>
                <p class="text-gray-600 mt-2">Bắt đầu hành trình của bạn</p>
            </div>

            <!-- Error Message -->
            <% if (typeof error !=='undefined' && error) { %>
                <div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6 flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <%= error %>
                </div>
                <% } %>

                    <!-- Register Form -->
                    <form id="registerForm" class="space-y-5">
                        <div>
                            <label for="username" class="block text-sm font-medium text-gray-700 mb-2">Tên đăng
                                nhập</label>
                            <input type="text" id="username" name="username" required minlength="3"
                                class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                                placeholder="username">
                        </div>

                        <div>
                            <label for="fullName" class="block text-sm font-medium text-gray-700 mb-2">Họ và tên</label>
                            <input type="text" id="fullName" name="fullName"
                                class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                                placeholder="Nguyễn Văn A">
                        </div>

                        <div>
                            <label for="email" class="block text-sm font-medium text-gray-700 mb-2">Email</label>
                            <input type="email" id="email" name="email" required
                                class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                                placeholder="email@example.com">
                        </div>

                        <div>
                            <label for="password" class="block text-sm font-medium text-gray-700 mb-2">Mật khẩu</label>
                            <div class="relative">
                                <input type="password" id="password" name="password" required minlength="8"
                                    class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                                    placeholder="Tối thiểu 8 ký tự">
                                <button type="button" id="togglePassword"
                                    class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z">
                                        </path>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div>
                            <label for="confirmPassword" class="block text-sm font-medium text-gray-700 mb-2">Xác nhận
                                mật khẩu</label>
                            <input type="password" id="confirmPassword" name="confirmPassword" required
                                class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                                placeholder="Nhập lại mật khẩu">
                        </div>

                        <div class="flex items-start">
                            <input type="checkbox" id="terms" required
                                class="w-4 h-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500 mt-1">
                            <label for="terms" class="ml-2 text-sm text-gray-600">
                                Tôi đồng ý với <a href="#" class="text-purple-600 hover:text-purple-700">Điều khoản dịch
                                    vụ</a> và <a href="#" class="text-purple-600 hover:text-purple-700">Chính sách bảo
                                    mật</a>
                            </label>
                        </div>

                        <button type="submit" id="submitBtn"
                            class="w-full py-3 px-4 btn-gradient text-white font-medium rounded-lg transition-all flex items-center justify-center">
                            <span id="btnText">Đăng ký</span>
                            <svg id="btnSpinner" class="hidden w-5 h-5 ml-2 animate-spin" fill="none"
                                viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                    stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor"
                                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                </path>
                            </svg>
                        </button>
                    </form>

                    <!-- Login Link -->
                    <div class="mt-8 text-center">
                        <p class="text-gray-600">
                            Đã có tài khoản?
                            <a href="/login" class="text-purple-600 hover:text-purple-700 font-medium">Đăng nhập</a>
                        </p>
                    </div>
        </div>
    </div>
</div>

<script>
    // Toggle password visibility
    document.getElementById('togglePassword').addEventListener('click', function () {
        const password = document.getElementById('password');
        password.type = password.type === 'password' ? 'text' : 'password';
    });

    // Form submission
    document.getElementById('registerForm').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('password').value;
        const confirmPassword = document.getElementById('confirmPassword').value;

        if (password !== confirmPassword) {
            alert('Mật khẩu xác nhận không khớp');
            return;
        }

        const btn = document.getElementById('submitBtn');
        const btnText = document.getElementById('btnText');
        const btnSpinner = document.getElementById('btnSpinner');

        btn.disabled = true;
        btnText.textContent = 'Đang đăng ký...';
        btnSpinner.classList.remove('hidden');

        try {
            const response = await fetch('/api/auth/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    username: document.getElementById('username').value,
                    email: document.getElementById('email').value,
                    password: password,
                    fullName: document.getElementById('fullName').value
                })
            });

            const data = await response.json();

            if (data.success) {
                // If server returns tokens, auto-login
                if (data.tokens && window.authManager) {
                    window.authManager.setTokens(data.tokens.accessToken, data.tokens.refreshToken);
                    window.location.href = '/dashboard';
                } else {
                    alert('Đăng ký thành công! Vui lòng đăng nhập.');
                    window.location.href = '/login';
                }
            } else {
                // Chi tiết lỗi validation
                let errorMsg = data.error || data.message || 'Đăng ký thất bại';

                // Nếu là lỗi Zod validation, parse và hiển thị chi tiết
                if (data.details && Array.isArray(data.details)) {
                    errorMsg = data.details.map(d => `${d.path}: ${d.message}`).join('\n');
                } else if (typeof data.error === 'object') {
                    // Zod error object
                    errorMsg = JSON.stringify(data.error, null, 2);
                }

                alert(errorMsg);
            }
        } catch (error) {
            console.error('[Register] Error:', error);
            alert('Có lỗi xảy ra. Vui lòng thử lại.');
        } finally {
            btn.disabled = false;
            btnText.textContent = 'Đăng ký';
            btnSpinner.classList.add('hidden');
        }
    });
</script>
</file>

<file path="backend/src/views/errors/404.ejs">
<div class="min-h-[80vh] flex items-center justify-center gradient-bg">
    <div class="text-center text-white px-4">
        <div class="animate-float">
            <div class="text-9xl font-bold opacity-20 mb-4">404</div>
        </div>
        <h1 class="text-4xl font-bold -mt-20 mb-4">Không tìm thấy trang</h1>
        <p class="text-xl text-white/80 mb-8 max-w-md mx-auto">
            Trang bạn đang tìm kiếm không tồn tại hoặc đã bị di chuyển.
        </p>
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <a href="/"
                class="inline-flex items-center justify-center px-6 py-3 bg-white text-purple-600 rounded-xl font-medium hover:bg-yellow-300 hover:text-purple-700 transition-all">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6">
                    </path>
                </svg>
                Về trang chủ
            </a>
            <a href="/dashboard"
                class="inline-flex items-center justify-center px-6 py-3 glass text-white rounded-xl font-medium hover:bg-white/20 transition-all">
                Dashboard
            </a>
        </div>
    </div>
</div>
</file>

<file path="backend/src/views/errors/500.ejs">
<div class="min-h-[80vh] flex items-center justify-center bg-gray-900">
    <div class="text-center text-white px-4">
        <div class="animate-float">
            <svg class="w-24 h-24 mx-auto text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z">
                </path>
            </svg>
        </div>
        <h1 class="text-4xl font-bold mt-6 mb-4">Lỗi máy chủ</h1>
        <p class="text-xl text-gray-400 mb-8 max-w-md mx-auto">
            Đã xảy ra lỗi không mong muốn. Chúng tôi đang khắc phục sự cố.
        </p>
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <a href="/"
                class="inline-flex items-center justify-center px-6 py-3 btn-gradient text-white rounded-xl font-medium">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6">
                    </path>
                </svg>
                Về trang chủ
            </a>
            <button onclick="window.location.reload()"
                class="inline-flex items-center justify-center px-6 py-3 border border-gray-600 text-gray-300 rounded-xl font-medium hover:bg-gray-800 transition-all">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15">
                    </path>
                </svg>
                Thử lại
            </button>
        </div>
    </div>
</div>
</file>

<file path="backend/src/views/layouts/main.ejs">
<!DOCTYPE html>
<html lang="vi" class="scroll-smooth">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        <%= typeof title !=='undefined' ? title + ' - ' : '' %>Document to Quiz
    </title>

    <!-- TailwindCSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        }
                    }
                }
            }
        }
    </script>

    <!-- Custom Styles -->
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .btn-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: all 0.3s ease;
        }

        .btn-gradient:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .animate-float {
            animation: float 3s ease-in-out infinite;
        }
    </style>
</head>

<body class="min-h-screen bg-gray-50 flex flex-col">
    <%- include('../partials/header') %>

        <%- include('../partials/flash') %>

            <main class="flex-1">
                <%- body %>
            </main>

            <%- include('../partials/footer') %>

                <!-- Global Scripts -->
                <script>
                    // Flash message auto-hide
                    setTimeout(() => {
                        const flash = document.getElementById('flash-message');
                        if (flash) {
                            flash.style.opacity = '0';
                            flash.style.transform = 'translateY(-20px)';
                            setTimeout(() => flash.remove(), 300);
                        }
                    }, 5000);
                </script>

                <!-- Auth Manager with Silent Refresh -->
                <%- include('../partials/auth') %>

</body>

</html>
</file>

<file path="backend/src/views/pages/dashboard.ejs">
<div class="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950">
    <!-- Animated Background Glow -->
    <div class="fixed inset-0 overflow-hidden pointer-events-none">
        <div class="absolute -top-40 -right-40 w-96 h-96 bg-purple-500/20 rounded-full blur-3xl"></div>
        <div class="absolute top-1/2 -left-40 w-80 h-80 bg-indigo-500/20 rounded-full blur-3xl"></div>
    </div>

    <!-- Dashboard Header -->
    <div class="relative z-10 pt-8 pb-6">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex flex-col md:flex-row md:items-end md:justify-between gap-6">
                <div>
                    <h1 class="text-4xl md:text-5xl font-black text-white tracking-tight">
                        Thư viện <span
                            class="text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-400">Quiz</span>
                    </h1>
                    <p class="text-slate-400 mt-2 text-lg">Quản lý và luyện tập bộ câu hỏi của bạn</p>
                </div>
                <a href="/upload"
                    class="group inline-flex items-center px-6 py-4 bg-gradient-to-r from-purple-600 to-indigo-600 text-white rounded-2xl font-bold hover:from-purple-500 hover:to-indigo-500 transition-all shadow-[0_10px_40px_-10px_rgba(147,51,234,0.5)] hover:shadow-[0_20px_50px_-10px_rgba(147,51,234,0.6)] hover:-translate-y-1 active:scale-95">
                    <svg class="w-5 h-5 mr-2 group-hover:rotate-90 transition-transform duration-300" fill="none"
                        stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 4v16m8-8H4">
                        </path>
                    </svg>
                    Tạo Quiz mới
                </a>
            </div>
        </div>
    </div>

    <!-- Stats Cards -->
    <div class="relative z-10 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mb-8">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div
                class="bg-white/5 backdrop-blur-xl rounded-2xl border border-white/10 p-5 flex items-center group hover:bg-white/10 transition-all">
                <div class="w-12 h-12 bg-purple-500/20 rounded-xl flex items-center justify-center">
                    <svg class="w-6 h-6 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                        </path>
                    </svg>
                </div>
                <div class="ml-4">
                    <p class="text-xs font-semibold text-slate-500 uppercase tracking-wider">Tổng Quiz</p>
                    <p class="text-2xl font-black text-white" id="totalQuizzes">0</p>
                </div>
            </div>
            <div
                class="bg-white/5 backdrop-blur-xl rounded-2xl border border-white/10 p-5 flex items-center group hover:bg-white/10 transition-all">
                <div class="w-12 h-12 bg-emerald-500/20 rounded-xl flex items-center justify-center">
                    <svg class="w-6 h-6 text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                </div>
                <div class="ml-4">
                    <p class="text-xs font-semibold text-slate-500 uppercase tracking-wider">Hoàn thành</p>
                    <p class="text-2xl font-black text-white" id="completedQuizzes">0</p>
                </div>
            </div>
            <div
                class="bg-white/5 backdrop-blur-xl rounded-2xl border border-white/10 p-5 flex items-center group hover:bg-white/10 transition-all">
                <div class="w-12 h-12 bg-amber-500/20 rounded-xl flex items-center justify-center">
                    <svg class="w-6 h-6 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                </div>
                <div class="ml-4">
                    <p class="text-xs font-semibold text-slate-500 uppercase tracking-wider">Đang xử lý</p>
                    <p class="text-2xl font-black text-white" id="processingQuizzes">0</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="relative z-10 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-16">
        <!-- Toolbar -->
        <div class="flex items-center justify-between mb-6">
            <h2 class="text-xl font-bold text-white flex items-center gap-2">
                <span class="w-2 h-2 bg-emerald-400 rounded-full animate-pulse"></span>
                Tất cả tài liệu
            </h2>
            <button onclick="loadQuizzes()"
                class="text-sm font-semibold text-slate-400 hover:text-white flex items-center gap-2 transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15">
                    </path>
                </svg>
                Làm mới
            </button>
        </div>

        <!-- Loading State -->
        <div id="loadingState" class="py-24 text-center">
            <div class="inline-block relative">
                <div class="w-16 h-16 border-4 border-purple-500/30 border-t-purple-500 rounded-full animate-spin">
                </div>
            </div>
            <p class="text-slate-500 mt-6 font-medium animate-pulse">Đang tải dữ liệu...</p>
        </div>

        <!-- Empty State -->
        <div id="emptyState" class="hidden py-24 text-center">
            <div class="w-24 h-24 bg-white/5 rounded-full flex items-center justify-center mx-auto mb-6">
                <svg class="w-12 h-12 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                </svg>
            </div>
            <h3 class="text-xl font-bold text-white">Chưa có Quiz nào</h3>
            <p class="text-slate-500 mt-2 max-w-sm mx-auto">Upload tài liệu PDF hoặc DOCX để AI tạo bộ câu hỏi trắc
                nghiệm</p>
            <a href="/upload"
                class="mt-8 inline-flex items-center px-8 py-3 bg-white text-slate-900 rounded-2xl font-bold hover:bg-slate-100 transition-all shadow-lg">
                Bắt đầu ngay
            </a>
        </div>

        <!-- Quiz Grid -->
        <div id="quizList" class="hidden grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
            <!-- Cards will be injected here -->
        </div>

        <!-- Pagination -->
        <div id="pagination" class="hidden mt-8 flex items-center justify-center gap-4">
            <button id="prevPage"
                class="px-5 py-2.5 bg-white/5 border border-white/10 rounded-xl text-sm font-bold text-white hover:bg-white/10 disabled:opacity-30 disabled:cursor-not-allowed transition-all">
                ← Trước
            </button>
            <span id="paginationInfo" class="text-sm text-slate-400"></span>
            <button id="nextPage"
                class="px-5 py-2.5 bg-white/5 border border-white/10 rounded-xl text-sm font-bold text-white hover:bg-white/10 disabled:opacity-30 disabled:cursor-not-allowed transition-all">
                Sau →
            </button>
        </div>
    </div>
</div>

<style>
    .quiz-card {
        background: rgba(255, 255, 255, 0.03);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .quiz-card:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.15);
        transform: translateY(-4px);
        box-shadow: 0 20px 40px -20px rgba(0, 0, 0, 0.5);
    }

    .section-chip {
        background: rgba(99, 102, 241, 0.15);
        color: rgb(165, 180, 252);
        transition: all 0.2s ease;
    }

    .section-chip:hover {
        background: rgba(99, 102, 241, 0.3);
    }

    /* Hidden scrollbar */
    .scrollbar-hidden {
        scrollbar-width: none;
        /* Firefox */
        -ms-overflow-style: none;
        /* IE/Edge */
    }

    .scrollbar-hidden::-webkit-scrollbar {
        display: none;
        /* Chrome/Safari */
    }
</style>

<script>
    let currentPage = 1;
    const limit = 12;
    const currentUserId = '<%= user?.id || "" %>';

    async function loadQuizzes(page = 1) {
        document.getElementById('loadingState').classList.remove('hidden');
        document.getElementById('emptyState').classList.add('hidden');
        document.getElementById('quizList').classList.add('hidden');
        document.getElementById('pagination').classList.add('hidden');

        try {
            const response = await fetch(`/api/v1/quizzes?page=${page}&limit=${limit}`);
            const data = await response.json();
            document.getElementById('loadingState').classList.add('hidden');

            if (!data.data || data.data.length === 0) {
                document.getElementById('emptyState').classList.remove('hidden');
                return;
            }

            const completed = data.data.filter(q => q.status === 'completed').length;
            const processing = data.data.filter(q => q.status === 'processing' || q.status === 'pending').length;
            document.getElementById('totalQuizzes').textContent = data.pagination?.total || data.data.length;
            document.getElementById('completedQuizzes').textContent = completed;
            document.getElementById('processingQuizzes').textContent = processing;

            const quizList = document.getElementById('quizList');
            quizList.innerHTML = data.data.map(quiz => {
                const isOwner = currentUserId && quiz.createdBy && quiz.createdBy.toString() === currentUserId;

                const statusConfig = {
                    'completed': { bg: 'bg-emerald-500/20', text: 'text-emerald-400', label: 'Sẵn sàng', dot: 'bg-emerald-400' },
                    'processing': { bg: 'bg-amber-500/20', text: 'text-amber-400', label: 'Đang xử lý', dot: 'bg-amber-400 animate-pulse' },
                    'pending': { bg: 'bg-slate-500/20', text: 'text-slate-400', label: 'Chờ xử lý', dot: 'bg-slate-400' },
                    'failed': { bg: 'bg-red-500/20', text: 'text-red-400', label: 'Lỗi', dot: 'bg-red-400' }
                };
                const status = statusConfig[quiz.status] || statusConfig.pending;

                const sections = quiz.sectionCounts && quiz.sectionCounts.length > 0
                    ? quiz.sectionCounts.slice(0, 4).map(sc =>
                        `<a href="/quiz/${quiz._id}/practice?section=${encodeURIComponent(sc.name)}" class="section-chip px-2.5 py-1 text-xs font-semibold rounded-lg">${sc.name} (${sc.count})</a>`
                    ).join('') + (quiz.sectionCounts.length > 4 ? `
                        <div class="relative inline-block">
                            <button onclick="event.stopPropagation(); toggleMoreSections('${quiz._id}')" class="section-chip px-2.5 py-1 text-xs font-semibold rounded-lg cursor-pointer hover:bg-indigo-500/30">
                                +${quiz.sectionCounts.length - 4}
                            </button>
                            <div id="more-sections-${quiz._id}" class="hidden absolute bottom-full left-0 mb-2 w-48 bg-slate-800 border border-white/10 rounded-xl shadow-2xl z-50 py-2">
                                ${quiz.sectionCounts.slice(4).map(sc =>
                        `<a href="/quiz/${quiz._id}/practice?section=${encodeURIComponent(sc.name)}" class="block px-3 py-2 text-sm text-slate-300 hover:bg-white/10 hover:text-white transition-colors">${sc.name} (${sc.count})</a>`
                    ).join('')}
                            </div>
                        </div>
                    ` : '')
                    : '';

                return `
                <div class="quiz-card rounded-2xl p-5 flex flex-col relative">
                    <!-- Delete Button - Top Right -->
                    <button onclick="event.stopPropagation(); deleteQuiz('${quiz._id}')" 
                        class="absolute top-3 right-3 p-2 text-slate-500 hover:text-red-400 hover:bg-red-500/20 rounded-lg transition-all opacity-50 hover:opacity-100" 
                        title="Xóa Quiz">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    </button>
                    
                    <!-- Header -->
                    <div class="flex items-center gap-2 mb-4">
                        <span class="w-2 h-2 ${status.dot} rounded-full"></span>
                        <span class="${status.bg} ${status.text} text-[10px] font-bold uppercase tracking-wider px-2 py-0.5 rounded-md">${status.label}</span>
                    </div>
                    
                    <!-- Title -->
                    <h3 class="text-lg font-bold text-white mb-2 line-clamp-2 leading-snug">${quiz.title || 'Untitled Quiz'}</h3>
                    
                    <!-- Meta -->
                    <div class="flex items-center gap-4 text-xs text-slate-500 mb-4">
                        <span class="flex items-center gap-1">
                            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            ${quiz.totalQuestions || 0} câu
                        </span>
                        <span class="flex items-center gap-1">
                            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                            ${new Date(quiz.createdAt).toLocaleDateString('vi-VN')}
                        </span>
                    </div>
                    
                    <!-- Actions -->
                    <div class="mt-auto pt-4 border-t border-white/5">
                        ${quiz.status === 'completed' ? `
                            <div class="flex gap-2">
                                <a href="/quiz/${quiz._id}/practice" class="flex-1 py-2.5 bg-gradient-to-r from-purple-600 to-indigo-600 text-white text-sm font-bold rounded-xl text-center hover:from-purple-500 hover:to-indigo-500 transition-all">
                                    Luyện tập
                                </a>
                                ${quiz.sectionCounts && quiz.sectionCounts.length > 0 ? `
                                    <div class="relative">
                                        <button onclick="event.stopPropagation(); toggleSections('${quiz._id}')" 
                                            class="px-3 py-2.5 bg-indigo-500/20 border border-indigo-500/30 rounded-xl text-indigo-400 hover:bg-indigo-500/30 hover:text-white transition-all flex items-center gap-1" 
                                            title="Chọn chương">
                                            <span class="text-xs font-bold">${quiz.sectionCounts.length}</span>
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                            </svg>
                                        </button>
                                        <div id="sections-${quiz._id}" class="hidden absolute bottom-full right-0 mb-2 w-52 bg-slate-800 border border-white/10 rounded-xl shadow-2xl z-50 py-2 max-h-64 overflow-y-auto scrollbar-hidden">
                                            <div class="px-3 py-2 text-[10px] font-bold text-slate-500 uppercase tracking-wider border-b border-white/5">Chọn chương</div>
                                            ${quiz.sectionCounts.map(sc =>
                    `<a href="/quiz/${quiz._id}/practice?section=${encodeURIComponent(sc.name)}" class="flex items-center justify-between px-3 py-2.5 text-sm text-slate-300 hover:bg-indigo-500/20 hover:text-white transition-colors">
                                                    <span class="truncate">${sc.name}</span>
                                                    <span class="text-[10px] font-bold bg-white/10 px-2 py-0.5 rounded-full text-slate-400">${sc.count}</span>
                                                </a>`
                ).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                <a href="/quiz/${quiz._id}" class="px-3 py-2.5 bg-white/5 border border-white/10 rounded-xl text-slate-400 hover:text-white hover:bg-white/10 transition-all" title="Chi tiết">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                                </a>
                            </div>
                        ` : quiz.status === 'processing' || quiz.status === 'pending' ? `
                            <a href="/quiz/${quiz._id}/status" class="block w-full py-2.5 bg-amber-500/10 text-amber-400 text-sm font-bold rounded-xl text-center border border-amber-500/20 hover:bg-amber-500/20 transition-all">
                                <span class="inline-block w-2 h-2 bg-amber-400 rounded-full animate-pulse mr-2"></span>
                                Đang phân tích...
                            </a>
                        ` : `
                            <span class="block w-full py-2.5 text-red-400 text-sm font-bold text-center">Xử lý thất bại</span>
                        `}
                    </div>
                </div>
            `}).join('');

            quizList.classList.remove('hidden');

            if (data.pagination && data.pagination.totalPages > 1) {
                const { page, totalPages, total } = data.pagination;
                currentPage = page;
                document.getElementById('paginationInfo').textContent = `Trang ${page} / ${totalPages}`;
                document.getElementById('prevPage').disabled = page <= 1;
                document.getElementById('nextPage').disabled = page >= totalPages;
                document.getElementById('pagination').classList.remove('hidden');
            }

        } catch (error) {
            console.error('Error loading quizzes:', error);
            document.getElementById('loadingState').classList.add('hidden');
        }
    }

    async function deleteQuiz(id) {
        if (!confirm('Bạn có chắc chắn muốn xóa Quiz này?')) return;
        try {
            const response = await window.authManager.fetchWithAuth(`/api/v1/quizzes/${id}`, { method: 'DELETE' });
            if (response.ok) { loadQuizzes(currentPage); }
        } catch (error) { alert('Có lỗi xảy ra'); }
    }

    document.getElementById('prevPage')?.addEventListener('click', () => { if (currentPage > 1) loadQuizzes(currentPage - 1); });
    document.getElementById('nextPage')?.addEventListener('click', () => { loadQuizzes(currentPage + 1); });

    function toggleSections(quizId) {
        const menu = document.getElementById(`sections-${quizId}`);
        if (menu) {
            // Close all other menus first
            document.querySelectorAll('[id^="sections-"]').forEach(el => {
                if (el.id !== `sections-${quizId}`) el.classList.add('hidden');
            });
            menu.classList.toggle('hidden');
        }
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', function (e) {
        if (!e.target.closest('[id^="sections-"]') && !e.target.closest('button')) {
            document.querySelectorAll('[id^="sections-"]').forEach(el => el.classList.add('hidden'));
        }
    });

    loadQuizzes();
</script>
</file>

<file path="backend/src/views/pages/home.ejs">
<!-- Hero Section -->
<section class="gradient-bg min-h-[80vh] flex items-center relative overflow-hidden">
    <!-- Decorative Elements -->
    <div class="absolute inset-0 opacity-10">
        <div class="absolute top-20 left-10 w-72 h-72 bg-white rounded-full blur-3xl"></div>
        <div class="absolute bottom-20 right-10 w-96 h-96 bg-white rounded-full blur-3xl"></div>
    </div>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-20 relative z-10">
        <div class="grid md:grid-cols-2 gap-12 items-center">
            <div class="text-white">
                <h1 class="text-4xl md:text-5xl lg:text-6xl font-bold mb-6 leading-tight">
                    Chuyển đổi tài liệu thành
                    <span class="block text-yellow-300">Bộ câu hỏi trắc nghiệm</span>
                </h1>
                <p class="text-xl text-white/80 mb-8 leading-relaxed">
                    Tự động tạo quiz từ file PDF và DOCX của bạn với công nghệ AI tiên tiến.
                    Tiết kiệm thời gian soạn đề, tập trung vào giảng dạy.
                </p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <a href="/register"
                        class="inline-flex items-center justify-center px-8 py-4 bg-white text-purple-600 rounded-xl font-bold text-lg hover:bg-yellow-300 hover:text-purple-700 transition-all duration-300 shadow-xl hover:shadow-2xl">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                        </svg>
                        Bắt đầu miễn phí
                    </a>
                    <a href="#features"
                        class="inline-flex items-center justify-center px-8 py-4 glass text-white rounded-xl font-bold text-lg hover:bg-white/20 transition-all duration-300">
                        Tìm hiểu thêm
                        <svg class="w-5 h-5 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </a>
                </div>
            </div>

            <!-- Illustration -->
            <div class="hidden md:block">
                <div class="animate-float">
                    <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20">
                        <div class="space-y-4">
                            <div class="flex items-center space-x-3">
                                <div class="w-12 h-12 bg-red-400 rounded-lg flex items-center justify-center">
                                    <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z" />
                                    </svg>
                                </div>
                                <div>
                                    <div class="text-white font-medium">document.pdf</div>
                                    <div class="text-white/60 text-sm">2.4 MB</div>
                                </div>
                            </div>
                            <div class="h-px bg-white/20"></div>
                            <div class="flex items-center justify-center py-4">
                                <svg class="w-8 h-8 text-yellow-300 animate-bounce" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M19 14l-7 7m0 0l-7-7m7 7V3"></path>
                                </svg>
                            </div>
                            <div class="bg-white/20 rounded-lg p-4">
                                <div class="text-yellow-300 font-medium mb-2">📝 Quiz Generated</div>
                                <div class="text-white/80 text-sm">25 câu hỏi • 4 đáp án/câu</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- Features Section -->
<section id="features" class="py-20 bg-white">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="text-center mb-16">
            <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4">
                Tính năng nổi bật
            </h2>
            <p class="text-xl text-gray-600 max-w-2xl mx-auto">
                Công cụ mạnh mẽ giúp bạn tạo bộ câu hỏi chất lượng cao một cách nhanh chóng
            </p>
        </div>

        <div class="grid md:grid-cols-3 gap-8">
            <!-- Feature 1 -->
            <div
                class="card-hover bg-gradient-to-br from-purple-50 to-indigo-50 rounded-2xl p-8 border border-purple-100">
                <div
                    class="w-14 h-14 bg-gradient-to-r from-purple-500 to-indigo-500 rounded-xl flex items-center justify-center mb-6">
                    <svg class="w-7 h-7 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                        </path>
                    </svg>
                </div>
                <h3 class="text-xl font-bold text-gray-900 mb-3">Upload đa định dạng</h3>
                <p class="text-gray-600">
                    Hỗ trợ PDF và DOCX. Chỉ cần kéo thả file và hệ thống sẽ tự động xử lý.
                </p>
            </div>

            <!-- Feature 2 -->
            <div
                class="card-hover bg-gradient-to-br from-green-50 to-emerald-50 rounded-2xl p-8 border border-green-100">
                <div
                    class="w-14 h-14 bg-gradient-to-r from-green-500 to-emerald-500 rounded-xl flex items-center justify-center mb-6">
                    <svg class="w-7 h-7 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z">
                        </path>
                    </svg>
                </div>
                <h3 class="text-xl font-bold text-gray-900 mb-3">AI thông minh</h3>
                <p class="text-gray-600">
                    Sử dụng Google Gemini AI để nhận diện đáp án đúng từ định dạng văn bản.
                </p>
            </div>

            <!-- Feature 3 -->
            <div
                class="card-hover bg-gradient-to-br from-orange-50 to-amber-50 rounded-2xl p-8 border border-orange-100">
                <div
                    class="w-14 h-14 bg-gradient-to-r from-orange-500 to-amber-500 rounded-xl flex items-center justify-center mb-6">
                    <svg class="w-7 h-7 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z">
                        </path>
                    </svg>
                </div>
                <h3 class="text-xl font-bold text-gray-900 mb-3">Chỉnh sửa dễ dàng</h3>
                <p class="text-gray-600">
                    Dễ dàng chỉnh sửa câu hỏi và đáp án sau khi tạo để đảm bảo chính xác.
                </p>
            </div>
        </div>
    </div>
</section>

<!-- CTA Section -->
<section class="py-20 bg-gray-900">
    <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
        <h2 class="text-3xl md:text-4xl font-bold text-white mb-6">
            Sẵn sàng tạo quiz đầu tiên?
        </h2>
        <p class="text-xl text-gray-400 mb-8">
            Đăng ký miễn phí và bắt đầu chuyển đổi tài liệu của bạn ngay hôm nay.
        </p>
        <a href="/register"
            class="inline-flex items-center px-8 py-4 btn-gradient text-white rounded-xl font-bold text-lg">
            Tạo tài khoản miễn phí
            <svg class="w-5 h-5 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6">
                </path>
            </svg>
        </a>
    </div>
</section>
</file>

<file path="backend/src/views/partials/auth.ejs">
<script>
    /**
     * Auth Utility - Silent Refresh & Token Management
     * Best Practice: Access token in memory, Refresh token in HttpOnly cookie
     */
    (function () {
        if (window.authManager) return;

        class AuthManager {
            constructor() {
                this.isRefreshing = false;
                this.refreshPromise = null;
                // Store access token in memory (NOT localStorage for security)
                this._accessToken = null;
                // Track if initial refresh has been attempted
                this._initialRefreshDone = false;
            }

            getAccessToken() {
                return this._accessToken;
            }

            setTokens(accessToken) {
                // Store in memory only - NOT in localStorage or regular cookies
                this._accessToken = accessToken;
            }

            clearTokens() {
                this._accessToken = null;
            }

            async refreshToken() {
                // If already refreshing, wait for existing promise
                if (this.isRefreshing && this.refreshPromise) {
                    return this.refreshPromise;
                }

                // If we already have a token, no need to refresh
                if (this._accessToken) {
                    return true;
                }

                this.isRefreshing = true;
                this.refreshPromise = (async () => {
                    try {
                        console.log('[Auth] Calling /api/auth/refresh-token...');
                        const response = await fetch('/api/auth/refresh-token', {
                            method: 'POST',
                            credentials: 'include' // Send HttpOnly cookie
                        });

                        console.log('[Auth] Response status:', response.status);
                        if (!response.ok) {
                            throw new Error('Refresh failed with status ' + response.status);
                        }

                        const data = await response.json();
                        console.log('[Auth] Response data:', data.success, data.tokens?.accessToken ? 'has token' : 'no token');
                        if (data.success && data.tokens?.accessToken) {
                            this.setTokens(data.tokens.accessToken);
                            console.log('[Auth] Token stored in memory');
                            return true;
                        }
                        return false;
                    } catch (e) {
                        console.error('[Auth] Refresh failed:', e);
                        return false;
                    } finally {
                        this.isRefreshing = false;
                        this._initialRefreshDone = true;
                        // Keep promise for a short time to handle rapid calls
                        setTimeout(() => {
                            this.refreshPromise = null;
                        }, 100);
                    }
                })();

                return this.refreshPromise;
            }

            async fetchWithAuth(url, options = {}, retried = false) {
                let token = this.getAccessToken();

                // If no token in memory, try silent refresh first
                if (!token && !retried) {
                    const refreshed = await this.refreshToken();
                    if (refreshed) {
                        token = this.getAccessToken();
                    }
                }

                if (!token) {
                    return fetch(url, options);
                }

                const headers = {
                    ...options.headers,
                    'Authorization': `Bearer ${token}`
                };

                const response = await fetch(url, { ...options, headers });

                // Auto-refresh on 401 (only once)
                if (response.status === 401 && !retried) {
                    this._accessToken = null; // Clear invalid token
                    const refreshed = await this.refreshToken();
                    if (refreshed) {
                        // Retry with new token
                        return this.fetchWithAuth(url, options, true);
                    }
                }

                return response;
            }

            async logout() {
                try {
                    await fetch('/api/auth/logout', {
                        method: 'POST',
                        credentials: 'include'
                    });
                } catch (e) {
                    console.error('[Auth] Logout error:', e);
                }
                this.clearTokens();
                window.location.href = '/login';
            }

            // Check if user might be logged in (has refresh token cookie)
            async checkAuthState() {
                if (this._accessToken) return true;
                // Try silent refresh to get access token
                return await this.refreshToken();
            }

            // Wait for initial refresh to complete (for pages that need token immediately)
            async waitForInitialRefresh() {
                if (this._initialRefreshDone) return this._accessToken !== null;
                if (this.refreshPromise) return await this.refreshPromise;
                return false;
            }
        }

        window.authManager = new AuthManager();

        // On page load, try silent refresh if user might be logged in
        // This restores access token from refresh token cookie
        window.authManager.refreshToken().catch(function () { });
    })();
</script>
</file>

<file path="backend/src/views/partials/flash.ejs">
<% if (typeof flash !=='undefined' && flash) { %>
    <% if (flash.success) { %>
        <div id="flash-message"
            class="fixed top-20 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 bg-green-500 text-white rounded-lg shadow-lg flex items-center space-x-2 transition-all duration-300">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
            <span>
                <%= flash.success %>
            </span>
        </div>
        <% } %>
            <% if (flash.error) { %>
                <div id="flash-message"
                    class="fixed top-20 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 bg-red-500 text-white rounded-lg shadow-lg flex items-center space-x-2 transition-all duration-300">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                    <span>
                        <%= flash.error %>
                    </span>
                </div>
                <% } %>
                    <% if (flash.info) { %>
                        <div id="flash-message"
                            class="fixed top-20 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 bg-blue-500 text-white rounded-lg shadow-lg flex items-center space-x-2 transition-all duration-300">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span>
                                <%= flash.info %>
                            </span>
                        </div>
                        <% } %>
                            <% } %>
</file>

<file path="backend/src/views/partials/footer.ejs">
<footer class="bg-gray-900 text-gray-300 mt-auto">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
            <!-- Brand -->
            <div class="col-span-1 md:col-span-2">
                <div class="flex items-center space-x-2 mb-4">
                    <div class="w-10 h-10 rounded-lg btn-gradient flex items-center justify-center">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                            </path>
                        </svg>
                    </div>
                    <span class="text-xl font-bold text-white">Doc2Quiz</span>
                </div>
                <p class="text-gray-400 max-w-md">
                    Chuyển đổi tài liệu PDF và DOCX thành bộ câu hỏi trắc nghiệm tự động với AI.
                </p>
            </div>

            <!-- Quick Links -->
            <div>
                <h3 class="text-white font-semibold mb-4">Liên kết nhanh</h3>
                <ul class="space-y-2">
                    <li><a href="/" class="hover:text-white transition-colors">Trang chủ</a></li>
                    <li><a href="/dashboard" class="hover:text-white transition-colors">Dashboard</a></li>
                    <li><a href="/upload" class="hover:text-white transition-colors">Upload tài liệu</a></li>
                </ul>
            </div>

            <!-- Support -->
            <div>
                <h3 class="text-white font-semibold mb-4">Hỗ trợ</h3>
                <ul class="space-y-2">
                    <li><a href="#" class="hover:text-white transition-colors">Hướng dẫn sử dụng</a></li>
                    <li><a href="#" class="hover:text-white transition-colors">FAQ</a></li>
                    <li><a href="#" class="hover:text-white transition-colors">Liên hệ</a></li>
                </ul>
            </div>
        </div>

        <div class="border-t border-gray-800 mt-8 pt-8 text-center text-gray-500">
            <p>&copy; <%= new Date().getFullYear() %> Document to Quiz. All rights reserved.</p>
        </div>
    </div>
</footer>
</file>

<file path="backend/src/views/partials/header.ejs">
<header class="bg-white shadow-sm sticky top-0 z-50">
    <nav class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between items-center h-16">
            <!-- Logo -->
            <a href="/" class="flex items-center space-x-2">
                <div class="w-10 h-10 rounded-lg btn-gradient flex items-center justify-center">
                    <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                        </path>
                    </svg>
                </div>
                <span
                    class="text-xl font-bold bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent">
                    Doc2Quiz
                </span>
            </a>

            <!-- Desktop Navigation -->
            <div class="hidden md:flex items-center space-x-8">
                <a href="/" class="text-gray-600 hover:text-purple-600 transition-colors font-medium">Trang chủ</a>
                <% if (typeof user !=='undefined' && user) { %>
                    <a href="/dashboard"
                        class="text-gray-600 hover:text-purple-600 transition-colors font-medium">Dashboard</a>
                    <a href="/upload"
                        class="text-gray-600 hover:text-purple-600 transition-colors font-medium">Upload</a>
                    <% } %>
            </div>

            <!-- Auth Buttons -->
            <div class="flex items-center space-x-4">
                <% if (typeof user !=='undefined' && user) { %>
                    <div class="flex items-center space-x-3">
                        <span class="text-gray-700 font-medium hidden sm:block">
                            <%= user.username || user.email %>
                        </span>
                        <div class="relative group">
                            <button
                                class="w-10 h-10 rounded-full bg-gradient-to-r from-purple-500 to-indigo-500 flex items-center justify-center text-white font-bold">
                                <%= (user.username || user.email || 'U' ).charAt(0).toUpperCase() %>
                            </button>
                            <div
                                class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg py-2 invisible group-hover:visible opacity-0 group-hover:opacity-100 transition-all duration-200">
                                <a href="/profile" class="block px-4 py-2 text-gray-700 hover:bg-gray-100">Hồ sơ</a>
                                <hr class="my-1">
                                <a href="javascript:void(0)" onclick="authManager.logout()"
                                    class="block px-4 py-2 text-red-600 hover:bg-gray-100">Đăng xuất</a>
                            </div>
                        </div>
                    </div>
                    <% } else { %>
                        <a href="/login" class="text-gray-600 hover:text-purple-600 transition-colors font-medium">Đăng
                            nhập</a>
                        <a href="/register" class="px-4 py-2 btn-gradient text-white rounded-lg font-medium">Đăng ký</a>
                        <% } %>
            </div>

            <!-- Mobile Menu Button -->
            <button id="mobile-menu-btn" class="md:hidden p-2 rounded-lg hover:bg-gray-100">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16">
                    </path>
                </svg>
            </button>
        </div>

        <!-- Mobile Menu -->
        <div id="mobile-menu" class="md:hidden hidden pb-4">
            <a href="/" class="block py-2 text-gray-600 hover:text-purple-600">Trang chủ</a>
            <% if (typeof user !=='undefined' && user) { %>
                <a href="/dashboard" class="block py-2 text-gray-600 hover:text-purple-600">Dashboard</a>
                <a href="/upload" class="block py-2 text-gray-600 hover:text-purple-600">Upload</a>
                <hr class="my-2">
                <a href="javascript:void(0)" onclick="authManager.logout()" class="block py-2 text-red-600">Đăng
                    xuất</a>
                <% } else { %>
                    <a href="/login" class="block py-2 text-gray-600 hover:text-purple-600">Đăng nhập</a>
                    <a href="/register" class="block py-2 text-purple-600 font-medium">Đăng ký</a>
                    <% } %>
        </div>
    </nav>
</header>

<script>
    document.getElementById('mobile-menu-btn')?.addEventListener('click', () => {
        document.getElementById('mobile-menu')?.classList.toggle('hidden');
    });
</script>
</file>

<file path="backend/src/views/quiz/detail.ejs">
<div class="min-h-screen bg-gray-50 py-8">
    <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
        <!-- Loading State -->
        <div id="loadingState" class="text-center py-20">
            <svg class="w-16 h-16 mx-auto text-purple-600 animate-spin" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <p class="text-gray-600 mt-4">Đang tải quiz...</p>
        </div>

        <!-- Error State -->
        <div id="errorState" class="hidden text-center py-20">
            <svg class="w-16 h-16 mx-auto text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <h2 class="text-xl font-bold text-gray-900 mt-4">Không thể tải quiz</h2>
            <p class="text-gray-600 mt-2" id="errorMessage">Quiz không tồn tại hoặc bạn không có quyền truy cập</p>
            <a href="/dashboard" class="mt-6 inline-flex items-center px-4 py-2 btn-gradient text-white rounded-lg">
                Quay lại Dashboard
            </a>
        </div>

        <!-- Quiz Content -->
        <div id="quizContent" class="hidden">
            <!-- Header -->
            <div class="flex items-center justify-between mb-8">
                <div>
                    <a href="/dashboard" class="text-purple-600 hover:text-purple-700 flex items-center mb-2">
                        <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7">
                            </path>
                        </svg>
                        Quay lại
                    </a>
                    <h1 class="text-3xl font-bold text-gray-900" id="quizTitle">Quiz Title</h1>
                    <p class="text-gray-600 mt-1" id="quizMeta">25 câu hỏi • Tạo ngày 22/12/2024</p>
                </div>
                <div class="flex items-center space-x-3">
                    <button onclick="exportQuiz()"
                        class="px-4 py-2 border border-purple-600 text-purple-600 rounded-lg hover:bg-purple-50 transition-colors flex items-center">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                        </svg>
                        Xuất file
                    </button>
                </div>
            </div>

            <!-- Questions List -->
            <div id="questionsList" class="space-y-6">
                <!-- Questions will be loaded here -->
            </div>
        </div>
    </div>
</div>

<script>
    const quizId = window.location.pathname.split('/').pop();

    async function loadQuiz() {
        try {
            // Public API - no auth required
            const response = await fetch(`/api/v1/quizzes/${quizId}`);

            if (!response.ok) {
                document.getElementById('loadingState').classList.add('hidden');
                document.getElementById('errorState').classList.remove('hidden');
                return;
            }

            const quiz = await response.json();

            document.getElementById('loadingState').classList.add('hidden');
            document.getElementById('quizContent').classList.remove('hidden');

            // Update header
            document.getElementById('quizTitle').textContent = quiz.title || 'Untitled Quiz';
            document.getElementById('quizMeta').textContent =
                `${quiz.totalQuestions || 0} câu hỏi • Tạo ngày ${new Date(quiz.createdAt).toLocaleDateString('vi-VN')}`;

            // Render questions
            const questionsList = document.getElementById('questionsList');
            questionsList.innerHTML = (quiz.questions || []).map((q, index) => `
                <div class="bg-white rounded-xl shadow-lg p-6 card-hover" id="question-${q.id}">
                    <div class="flex items-start justify-between mb-4">
                        <div class="flex items-center">
                            <span class="w-8 h-8 bg-purple-100 text-purple-600 rounded-lg flex items-center justify-center font-bold text-sm">
                                ${index + 1}
                            </span>
                            <h3 class="ml-3 text-lg font-medium text-gray-900">${escapeHtml(q.stem)}</h3>
                        </div>
                        <span class="px-2 py-1 text-xs font-medium rounded-full ${q.correctAnswerKey ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'}">
                            ${q.correctAnswerKey ? 'Đã có đáp án' : 'Chưa có đáp án'}
                        </span>
                    </div>
                    
                    <div class="space-y-2 ml-11">
                        ${(q.choices || []).map(choice => `
                            <div class="flex items-center p-3 rounded-lg ${q.correctAnswerKey === choice.key ? 'bg-green-50 border border-green-200' : 'bg-gray-50'}">
                                <span class="w-6 h-6 rounded-full ${q.correctAnswerKey === choice.key ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-600'} flex items-center justify-center text-sm font-medium mr-3">
                                    ${choice.key}
                                </span>
                                <span class="${q.correctAnswerKey === choice.key ? 'text-green-700 font-medium' : 'text-gray-700'}">${escapeHtml(choice.text)}</span>
                                ${q.correctAnswerKey === choice.key ? `
                                    <svg class="w-5 h-5 text-green-500 ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                    </svg>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                    
                    ${q.explanation ? `
                        <div class="mt-4 ml-11 p-3 bg-blue-50 rounded-lg">
                            <p class="text-sm text-blue-800">
                                <strong>Giải thích:</strong> ${escapeHtml(q.explanation)}
                            </p>
                        </div>
                    ` : ''}
                    
                    <!-- Edit Answer Button -->
                    <div class="mt-4 ml-11">
                        <button onclick="showEditModal('${q.id}', '${q.correctAnswerKey || ''}')" class="text-purple-600 hover:text-purple-700 text-sm font-medium">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                            </svg>
                            Sửa đáp án
                        </button>
                    </div>
                </div>
            `).join('');

        } catch (error) {
            console.error('Error loading quiz:', error);
            document.getElementById('loadingState').classList.add('hidden');
            document.getElementById('errorState').classList.remove('hidden');
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function showEditModal(questionId, currentAnswer) {
        const newAnswer = prompt('Nhập đáp án đúng (A, B, C, D...):', currentAnswer);
        if (newAnswer && newAnswer !== currentAnswer) {
            updateAnswer(questionId, newAnswer.toUpperCase());
        }
    }

    async function updateAnswer(questionId, newAnswer) {
        try {
            const response = await window.authManager.fetchWithAuth(`/api/v1/quizzes/${quizId}/questions/${questionId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ correctAnswerKey: newAnswer })
            });

            if (response.ok) {
                loadQuiz(); // Reload to show updated answer
            } else {
                alert('Không thể cập nhật đáp án');
            }
        } catch (error) {
            alert('Có lỗi xảy ra');
        }
    }

    function exportQuiz() {
        // Download highlighted DOCX
        window.location.href = `/api/v1/quizzes/${quizId}/download`;
    }

    loadQuiz();
</script>
</file>

<file path="backend/src/views/quiz/practice.ejs">
<%- contentFor('title') %>
    Học Quiz - Ghi Nhớ Cốt Lõi

    <%- contentFor('body') %>
        <div
            class="h-[calc(100vh-5rem)] bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 flex flex-col overflow-hidden font-sans text-slate-200 relative">
            <!-- Background Glow -->
            <div class="fixed inset-0 overflow-hidden pointer-events-none">
                <div class="absolute -top-40 -right-40 w-80 h-80 bg-purple-500/10 rounded-full blur-3xl"></div>
                <div class="absolute bottom-0 -left-40 w-60 h-60 bg-indigo-500/10 rounded-full blur-3xl"></div>
            </div>

            <!-- TOP HEADER: Tối giản diện tích -->
            <div class="max-w-4xl mx-auto w-full px-4 pt-3 flex-none">
                <div class="flex items-center justify-between mb-2">
                    <a href="/dashboard"
                        class="text-slate-500 hover:text-white font-black text-xs uppercase tracking-tighter flex items-center">
                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path d="M15 19l-7-7 7-7" stroke-width="3"></path>
                        </svg>
                        THOÁT
                    </a>

                    <div class="flex items-center gap-3">
                        <div class="flex items-center gap-1">
                            <span class="text-[10px] font-black text-slate-500 uppercase">Đúng</span>
                            <div class="bg-emerald-500/20 border border-emerald-500/50 px-3 py-0.5 rounded shadow-[0_0_10px_rgba(16,185,129,0.2)] text-emerald-400 font-black text-sm"
                                id="correctCount">0</div>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="text-[10px] font-black text-slate-500 uppercase">Sai</span>
                            <div class="bg-rose-500/20 border border-rose-500/50 px-3 py-0.5 rounded shadow-[0_0_10px_rgba(244,63,94,0.2)] text-rose-400 font-black text-sm"
                                id="wrongCount">0</div>
                        </div>
                    </div>
                </div>

                <!-- Thanh tiến trình mảnh -->
                <div class="h-1.5 bg-white/5 rounded-full overflow-hidden border border-white/5">
                    <div id="progressBar"
                        class="h-full bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 transition-all duration-700 shadow-[0_0_15px_rgba(168,85,247,0.4)]"
                        style="width: 0%"></div>
                </div>
            </div>

            <!-- MAIN AREA: Chiếm toàn bộ không gian còn lại -->
            <div class="max-w-4xl mx-auto w-full pb-4 flex-1 flex flex-col min-h-0 mt-2">

                <!-- Section Info Badge -->
                <div id="sectionInfo"
                    class="hidden text-center mb-2 px-4 py-2 bg-purple-500/20 border border-purple-500/30 rounded-lg text-purple-300 font-semibold">
                </div>

                <div id="flashcardContainer" class="flex-1 flex flex-col min-h-0">

                    <!-- Loading State -->
                    <div id="loadingState" class="flex flex-col items-center justify-center h-full">
                        <div
                            class="animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent mb-4">
                        </div>
                        <p class="font-black text-slate-400 uppercase tracking-widest text-xs">Đang tải kiến thức...</p>
                    </div>

                    <!-- Question Card -->
                    <div id="questionCard" class="hidden h-full flex flex-col min-h-0">

                        <!-- Vùng nội dung có thể cuộn nội bộ -->
                        <div class="flex-1 overflow-y-auto pr-2 custom-scroll">
                            <div class="mb-4">
                                <span
                                    class="bg-slate-800 text-slate-400 px-2 py-0.5 rounded text-[10px] font-black uppercase tracking-widest border border-slate-700">CÂU
                                    <span id="questionNumber">1</span></span>
                                <h2 id="questionText"
                                    class="text-xl md:text-2xl text-white font-black leading-tight mt-2 italic tracking-tight">
                                </h2>
                            </div>

                            <!-- Choices Grid: 2 cột trên PC -->
                            <div id="choicesContainer"
                                class="grid grid-cols-1 md:grid-cols-2 gap-3 transition-all duration-500 mx-5">
                                <!-- JS sẽ render đáp án ở đây -->
                            </div>

                            <!-- Ghi nhớ cốt lõi: Dark Theme -->
                            <div id="explanationBox" class="hidden mt-4 transform animate-in zoom-in duration-300">
                                <div
                                    class="bg-slate-800/80 backdrop-blur-xl rounded-2xl p-5 shadow-2xl border border-white/10">
                                    <div class="flex items-center mb-4">
                                        <div class="bg-gradient-to-r from-purple-500 to-indigo-500 p-2 rounded-lg mr-3">
                                            <svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                <path
                                                    d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1a1 1 0 112 0v1a1 1 0 11-2 0zM13.536 14.95a1 1 0 011.414 0l.707.707a1 1 0 01-1.414 1.414l-.707-.707a1 1 0 010-1.414zM6.464 14.95l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414z">
                                                </path>
                                            </svg>
                                        </div>
                                        <h3 class="text-white font-black uppercase tracking-tight text-base">Ghi nhớ cốt
                                            lõi</h3>
                                    </div>

                                    <!-- Câu trả lời đúng -->
                                    <div class="bg-emerald-500/20 border-l-4 border-emerald-400 p-4 rounded-r-xl mb-4">
                                        <p class="text-emerald-400 text-[10px] font-black uppercase mb-1">Câu trả lời
                                            đúng:</p>
                                        <p id="repeatAnswer" class="text-white font-bold text-lg leading-tight"></p>
                                    </div>

                                    <p id="explanationText" class="text-slate-300 font-medium text-sm leading-relaxed">
                                    </p>

                                    <div
                                        class="mt-4 pt-3 border-t border-white/10 flex justify-between items-center text-[9px] font-bold text-slate-500 uppercase tracking-widest">
                                        <span>AI Powered</span>
                                        <span class="text-emerald-400 flex items-center gap-1">
                                            <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd"
                                                    d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                                                    clip-rule="evenodd"></path>
                                            </svg>
                                            Verified
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Nút Tiếp tục cố định ở đáy -->
                        <div class="py-3 flex-none">
                            <button id="nextButton" onclick="nextQuestion()"
                                class="hidden w-full py-4 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 text-white font-black rounded-2xl transition-all shadow-[0_10px_30px_-10px_rgba(147,51,234,0.5)] active:scale-95 uppercase tracking-[0.15em] text-lg">
                                TIẾP TỤC HỌC →
                            </button>
                            <p id="hintText"
                                class="text-center font-bold text-slate-600 uppercase text-[9px] tracking-[0.3em] animate-pulse">
                                Chọn phương án (Phím A/B/C/D) • Tiếp tục (Enter)</p>
                        </div>
                    </div>
                </div>

                <!-- Results Panel -->
                <div id="resultsPanel" class="hidden h-full flex items-center justify-center">
                    <div
                        class="bg-slate-900 rounded-[2.5rem] p-8 border-2 border-slate-800 text-center w-full max-w-md shadow-2xl">
                        <div class="text-5xl mb-4">✨</div>
                        <h2 class="text-2xl font-black text-white mb-2 uppercase tracking-tighter">Hoàn thành bài học
                        </h2>
                        <div class="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 mb-6"
                            id="finalScore">0%</div>

                        <div class="flex flex-col gap-3">
                            <button onclick="retryQuiz()"
                                class="py-4 bg-white text-black font-black rounded-2xl text-lg uppercase transition-all hover:bg-yellow-400">Làm
                                lại</button>
                            <a href="/dashboard"
                                class="py-4 bg-slate-800 text-white font-black rounded-2xl text-lg uppercase">Dashboard</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <style>
            /* Màu sắc đặc trưng cho A, B, C, D */
            .btn-A {
                --c: #3b82f6;
                --g: rgba(59, 130, 246, 0.4);
            }

            .btn-B {
                --c: #a855f7;
                --g: rgba(168, 85, 247, 0.4);
            }

            .btn-C {
                --c: #ec4899;
                --g: rgba(236, 72, 153, 0.4);
            }

            .btn-D {
                --c: #f59e0b;
                --g: rgba(245, 158, 11, 0.4);
            }

            .choice-btn {
                background: #0f172a;
                border: 2px solid #1e293b;
                transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                position: relative;
            }

            .choice-btn:hover:not(.choices-active .choice-btn) {
                transform: translateY(-2px);
                border-color: var(--c);
                box-shadow: 0 4px 12px var(--g);
            }

            .choice-btn .key-tag {
                background: var(--c);
                color: white;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                transition: all 0.3s ease;
            }

            /* Khi đã trả lời - các câu sai mờ đi mượt mà */
            .choices-active .choice-btn:not(.is-correct):not(.is-wrong-selection) {
                opacity: 0.2;
                transform: scale(0.95);
                filter: grayscale(1) blur(1px);
                pointer-events: none;
                transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* Đáp án đúng - nổi bật với hiệu ứng pulse */
            .choice-btn.is-correct {
                border-color: #10b981 !important;
                transform: scale(1.03);
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.5), 0 0 40px rgba(16, 185, 129, 0.3);
                z-index: 20;
                opacity: 1 !important;
                animation: correctPulse 1.5s ease-in-out infinite;
            }

            .choice-btn.is-correct .key-tag {
                background: #10b981 !important;
            }

            @keyframes correctPulse {

                0%,
                100% {
                    box-shadow: 0 0 20px rgba(16, 185, 129, 0.5), 0 0 40px rgba(16, 185, 129, 0.3);
                }

                50% {
                    box-shadow: 0 0 30px rgba(16, 185, 129, 0.7), 0 0 60px rgba(16, 185, 129, 0.4);
                }
            }

            /* Đáp án sai được chọn - shake mượt + highlight đỏ */
            .choice-btn.is-wrong-selection {
                border-color: #ef4444 !important;
                background: rgba(239, 68, 68, 0.1) !important;
                opacity: 1 !important;
                filter: none !important;
                animation: wrongShake 0.6s ease;
            }

            .choice-btn.is-wrong-selection .key-tag {
                background: #ef4444 !important;
            }

            @keyframes wrongShake {

                0%,
                100% {
                    transform: translateX(0);
                }

                10%,
                30%,
                50%,
                70%,
                90% {
                    transform: translateX(-4px);
                }

                20%,
                40%,
                60%,
                80% {
                    transform: translateX(4px);
                }
            }

            /* Explanation box animation */
            #explanationBox {
                animation: slideUp 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            }

            @keyframes slideUp {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }

                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .custom-scroll::-webkit-scrollbar {
                width: 4px;
            }

            .custom-scroll::-webkit-scrollbar-thumb {
                background: #1e293b;
                border-radius: 10px;
            }
        </style>

        <script>
            let quizData = null;
            let currentQuestionIndex = 0;
            let correctCount = 0;
            let wrongCount = 0;
            let answered = false;
            const quizId = '<%= quizId %>';

            // Fisher-Yates shuffle algorithm
            function shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            async function loadQuiz() {
                try {
                    const response = await window.authManager.fetchWithAuth(`/api/v1/quizzes/${quizId}`);
                    if (!response.ok) throw new Error('Fail');
                    quizData = await response.json();

                    // Check if section filter is specified in URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const sectionFilter = urlParams.get('section');

                    if (sectionFilter) {
                        // Normalize: remove all spaces and uppercase for comparison
                        const normalizedFilter = sectionFilter.replace(/\s+/g, '').toUpperCase();
                        console.log('[Practice] Normalized filter (no spaces):', normalizedFilter);

                        quizData.questions = quizData.questions.filter(function (q) {
                            // Remove spaces from section too before comparing
                            const normalizedSection = (q.section || '').replace(/\s+/g, '').toUpperCase();
                            return normalizedSection === normalizedFilter;
                        });

                        console.log('[Practice] Filtered count:', quizData.questions.length);

                        // Show section name in title
                        document.getElementById('sectionInfo').textContent = `📚 ${sectionFilter} (${quizData.questions.length} câu)`;
                        document.getElementById('sectionInfo').classList.remove('hidden');
                    }

                    // Shuffle questions for random order each time
                    quizData.questions = shuffleArray(quizData.questions);

                    document.getElementById('loadingState').classList.add('hidden');
                    document.getElementById('questionCard').classList.remove('hidden');
                    showQuestion(0);
                } catch (e) {
                    document.getElementById('loadingState').innerHTML = `<p class="text-rose-500 font-black">LỖI TẢI DỮ LIỆU</p>`;
                }
            }

            function showQuestion(index) {
                const question = quizData.questions[index];
                answered = false;

                document.getElementById('questionNumber').textContent = index + 1;
                document.getElementById('questionText').textContent = question.stem;
                document.getElementById('explanationBox').classList.add('hidden');
                document.getElementById('nextButton').classList.add('hidden');
                document.getElementById('hintText').classList.remove('hidden');

                const container = document.getElementById('choicesContainer');
                container.classList.remove('choices-active');

                container.innerHTML = question.choices.map(choice => `
                <button onclick="selectAnswer('${choice.key}')" 
                        id="btn-${choice.key}"
                        class="choice-btn btn-${choice.key} flex items-center p-3.5 rounded-2xl text-left">
                    <span class="key-tag w-9 h-9 flex-none flex items-center justify-center rounded-xl text-lg font-black mr-3 uppercase">
                        ${choice.key}
                    </span>
                    <span class="text-white font-bold text-base leading-tight">${escapeHtml(choice.text)}</span>
                </button>
            `).join('');

                updateProgress();
                // Cuộn nội dung lên đầu
                document.querySelector('.custom-scroll').scrollTop = 0;
            }

            function selectAnswer(choiceKey) {
                if (answered) return;
                answered = true;

                const question = quizData.questions[currentQuestionIndex];
                const correctKey = question.correctAnswerKey;
                const isCorrect = choiceKey === correctKey;

                if (isCorrect) correctCount++; else wrongCount++;
                document.getElementById('correctCount').textContent = correctCount;
                document.getElementById('wrongCount').textContent = wrongCount;

                // Hiệu ứng Visual
                document.getElementById('choicesContainer').classList.add('choices-active');
                document.getElementById(`btn-${correctKey}`).classList.add('is-correct');
                if (!isCorrect) document.getElementById(`btn-${choiceKey}`).classList.add('is-wrong-selection');

                // Ghim kiến thức vào box xanh
                const correctChoiceObj = question.choices.find(c => c.key === correctKey);
                document.getElementById('repeatAnswer').textContent = `${correctKey}. ${correctChoiceObj.text}`;

                // Nếu trả lời sai -> Gọi AI giải thích
                if (!isCorrect) {
                    document.getElementById('explanationText').innerHTML = '<span class="animate-pulse">AI đang phân tích...</span>';
                    document.getElementById('explanationBox').classList.remove('hidden');

                    // Gọi API giải thích (dùng fetch thường vì endpoint có thể public)
                    fetch(`/api/v1/quizzes/${quizId}/questions/${question.id}/explain`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ userAnswerKey: choiceKey })
                    })
                        .then(res => res.json())
                        .then(data => {
                            if (data.explanation) {
                                document.getElementById('explanationText').textContent = data.explanation;
                            } else if (data.error) {
                                document.getElementById('explanationText').textContent = "Đăng nhập để xem giải thích chi tiết từ AI.";
                            }
                        })
                        .catch(err => {
                            console.error('[Practice] Explain error:', err);
                            document.getElementById('explanationText').textContent = "Hãy ghi nhớ đáp án đúng này.";
                        });
                } else {
                    // Đúng -> hiện message
                    document.getElementById('explanationText').textContent = "Tuyệt vời! Bạn đã nắm vững kiến thức này.";
                    document.getElementById('explanationBox').classList.remove('hidden');
                }

                document.getElementById('nextButton').classList.remove('hidden');
                document.getElementById('hintText').classList.add('hidden');

                // Tự động cuộn nhẹ đến phần giải thích
                setTimeout(() => {
                    document.getElementById('explanationBox').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);

                if (currentQuestionIndex >= quizData.questions.length - 1) {
                    document.getElementById('nextButton').textContent = 'XEM KẾT QUẢ CUỐI';
                }
            }

            function nextQuestion() {
                currentQuestionIndex++;
                if (currentQuestionIndex >= quizData.questions.length) showResults();
                else showQuestion(currentQuestionIndex);
            }

            function updateProgress() {
                const percent = Math.round((currentQuestionIndex / quizData.questions.length) * 100);
                document.getElementById('progressBar').style.width = `${percent}%`;
            }

            function showResults() {
                document.getElementById('flashcardContainer').classList.add('hidden');
                document.getElementById('resultsPanel').classList.remove('hidden');
                const percent = Math.round((correctCount / quizData.questions.length) * 100);
                document.getElementById('finalScore').textContent = `${percent}%`;
            }

            function retryQuiz() { location.reload(); }
            function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t || ''; return d.innerHTML; }

            document.addEventListener('DOMContentLoaded', loadQuiz);

            // Keyboard shortcuts: A, B, C, D (or 1, 2, 3, 4) để chọn đáp án, Enter/Space để tiếp tục
            document.addEventListener('keydown', function (e) {
                // Ignore if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                const key = e.key.toUpperCase();

                // Map phím số sang chữ cái
                const keyMap = { '1': 'A', '2': 'B', '3': 'C', '4': 'D' };
                const mappedKey = keyMap[key] || key;

                // Chọn đáp án bằng phím A, B, C, D hoặc 1, 2, 3, 4
                if (['A', 'B', 'C', 'D'].includes(mappedKey)) {
                    if (!answered && quizData && document.getElementById(`btn-${mappedKey}`)) {
                        selectAnswer(mappedKey);
                    }
                }

                // Nhấn Enter hoặc Space để tiếp tục
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault(); // Prevent page scroll on Space
                    const nextBtn = document.getElementById('nextButton');
                    if (nextBtn && !nextBtn.classList.contains('hidden')) {
                        nextQuestion();
                    }
                }
            });
        </script>
</file>

<file path="backend/src/views/quiz/processing.ejs">
<div class="min-h-screen bg-gray-50 py-12">
    <div class="max-w-2xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="bg-white rounded-2xl shadow-lg p-8 text-center">
            <!-- Status Icon -->
            <div id="statusIcon"
                class="w-24 h-24 mx-auto rounded-full flex items-center justify-center mb-6 bg-purple-100">
                <svg class="w-12 h-12 text-purple-600 animate-spin" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
            </div>

            <!-- Status Title -->
            <h1 class="text-2xl font-bold text-gray-900" id="statusTitle">Đang xử lý...</h1>
            <p class="text-gray-600 mt-2" id="statusMessage">Hệ thống đang phân tích tài liệu của bạn</p>

            <!-- Progress Bar -->
            <div class="mt-8">
                <div class="h-2 bg-gray-200 rounded-full overflow-hidden">
                    <div id="progressBar"
                        class="h-full bg-gradient-to-r from-purple-500 to-indigo-500 rounded-full transition-all duration-500"
                        style="width: 0%"></div>
                </div>
                <p class="text-sm text-gray-500 mt-2" id="progressText">0%</p>
            </div>

            <!-- Status Details -->
            <div id="statusDetails" class="mt-8 p-4 bg-gray-50 rounded-lg text-left">
                <h3 class="font-medium text-gray-900 mb-3">Tiến trình xử lý:</h3>
                <ul class="space-y-2" id="stepsList">
                    <li class="flex items-center text-gray-600">
                        <span class="w-5 h-5 mr-3 flex items-center justify-center">
                            <svg class="w-4 h-4 text-gray-400 animate-spin" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                    stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor"
                                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                            </svg>
                        </span>
                        Đọc tài liệu...
                    </li>
                </ul>
            </div>

            <!-- Action Buttons (hidden initially) -->
            <div id="actionButtons" class="mt-8 space-y-3 hidden">
                <a href="#" id="viewQuizBtn"
                    class="block w-full py-3 px-4 btn-gradient text-white font-medium rounded-lg transition-all">
                    Xem Quiz
                </a>
                <a href="/dashboard"
                    class="block w-full py-3 px-4 border border-gray-300 text-gray-700 font-medium rounded-lg hover:bg-gray-50 transition-all">
                    Quay lại Dashboard
                </a>
            </div>

            <!-- Error Retry Button (hidden initially) -->
            <div id="retryButton" class="mt-8 hidden">
                <a href="/upload"
                    class="inline-flex items-center px-6 py-3 btn-gradient text-white font-medium rounded-lg">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15">
                        </path>
                    </svg>
                    Thử lại
                </a>
            </div>
        </div>
    </div>
</div>

<script>
    const quizId = window.location.pathname.split('/')[2];
    let pollInterval;

    const steps = [
        { key: 'reading', label: 'Đọc tài liệu' },
        { key: 'parsing', label: 'Phân tích cấu trúc' },
        { key: 'detecting', label: 'Nhận diện câu hỏi và đáp án' },
        { key: 'ai_processing', label: 'Xử lý bằng AI' },
        { key: 'saving', label: 'Lưu kết quả' }
    ];

    async function checkStatus() {
        if (!window.authManager || !window.authManager.getAccessToken()) {
            window.location.href = '/login';
            return;
        }

        try {
            const response = await window.authManager.fetchWithAuth(`/api/v1/quizzes/${quizId}/status`);

            if (response.status === 401) {
                window.authManager.clearTokens();
                window.location.href = '/login';
                return;
            }

            const data = await response.json();

            updateUI(data);

            if (data.status === 'completed' || data.status === 'failed') {
                clearInterval(pollInterval);
            }

        } catch (error) {
            console.error('Error checking status:', error);
        }
    }

    function updateUI(data) {
        const statusIcon = document.getElementById('statusIcon');
        const statusTitle = document.getElementById('statusTitle');
        const statusMessage = document.getElementById('statusMessage');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        switch (data.status) {
            case 'completed':
                statusIcon.innerHTML = `
                    <svg class="w-12 h-12 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                `;
                statusIcon.className = 'w-24 h-24 mx-auto rounded-full flex items-center justify-center mb-6 bg-green-100';
                statusTitle.textContent = 'Hoàn thành!';
                statusMessage.textContent = `Quiz đã sẵn sàng với ${data.questionCount || 0} câu hỏi`;
                progressBar.style.width = '100%';
                progressText.textContent = '100%';

                document.getElementById('viewQuizBtn').href = `/quiz/${quizId}`;
                document.getElementById('actionButtons').classList.remove('hidden');
                document.getElementById('statusDetails').classList.add('hidden');
                break;

            case 'failed':
                statusIcon.innerHTML = `
                    <svg class="w-12 h-12 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                `;
                statusIcon.className = 'w-24 h-24 mx-auto rounded-full flex items-center justify-center mb-6 bg-red-100';
                statusTitle.textContent = 'Xử lý thất bại';
                statusMessage.textContent = data.error || 'Đã xảy ra lỗi trong quá trình xử lý';

                document.getElementById('retryButton').classList.remove('hidden');
                document.getElementById('statusDetails').classList.add('hidden');
                break;

            case 'processing':
            case 'pending':
            default:
                const progress = data.progress || 0;
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${progress}%`;

                // Update steps
                updateSteps(data.currentStep || 'reading');
                break;
        }
    }

    function updateSteps(currentStep) {
        const stepsList = document.getElementById('stepsList');
        const currentIndex = steps.findIndex(s => s.key === currentStep);

        stepsList.innerHTML = steps.map((step, index) => {
            let icon, textClass;

            if (index < currentIndex) {
                // Completed
                icon = `<svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>`;
                textClass = 'text-green-600';
            } else if (index === currentIndex) {
                // Current
                icon = `<svg class="w-4 h-4 text-purple-600 animate-spin" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                </svg>`;
                textClass = 'text-purple-600 font-medium';
            } else {
                // Pending
                icon = `<div class="w-4 h-4 border-2 border-gray-300 rounded-full"></div>`;
                textClass = 'text-gray-400';
            }

            return `
                <li class="flex items-center ${textClass}">
                    <span class="w-5 h-5 mr-3 flex items-center justify-center">${icon}</span>
                    ${step.label}
                </li>
            `;
        }).join('');
    }

    // Initial check
    checkStatus();

    // Poll every 2 seconds
    pollInterval = setInterval(checkStatus, 2000);
</script>
</file>

<file path="backend/src/views/quiz/upload.ejs">
<div class="min-h-screen bg-gray-50 py-12">
    <div class="max-w-3xl mx-auto px-4 sm:px-6 lg:px-8">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-900">Upload Tài Liệu</h1>
            <p class="text-gray-600 mt-2">Tải lên file PDF hoặc DOCX để tạo bộ câu hỏi trắc nghiệm</p>
        </div>

        <!-- Upload Form -->
        <div class="bg-white rounded-2xl shadow-lg p-8">
            <form id="uploadForm" enctype="multipart/form-data">
                <!-- Title Input -->
                <div class="mb-6">
                    <label for="title" class="block text-sm font-medium text-gray-700 mb-2">Tiêu đề Quiz</label>
                    <input type="text" id="title" name="title" required
                        class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                        placeholder="Nhập tiêu đề cho bộ câu hỏi">
                </div>

                <!-- Drag & Drop Zone -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Tài liệu</label>
                    <div id="dropZone"
                        class="border-2 border-dashed border-gray-300 rounded-xl p-12 text-center cursor-pointer hover:border-purple-500 hover:bg-purple-50 transition-all">
                        <div id="uploadIcon" class="mx-auto">
                            <svg class="w-16 h-16 mx-auto text-gray-400" fill="none" stroke="currentColor"
                                viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                                </path>
                            </svg>
                        </div>
                        <p class="text-gray-600 mt-4" id="dropText">
                            Kéo thả file vào đây hoặc <span class="text-purple-600 font-medium">nhấn để chọn</span>
                        </p>
                        <p class="text-sm text-gray-500 mt-2">Hỗ trợ PDF và DOCX (tối đa 50MB)</p>
                        <input type="file" id="fileInput" name="file" accept=".pdf,.docx" class="hidden" required>
                    </div>

                    <!-- Selected File Info -->
                    <div id="fileInfo"
                        class="hidden mt-4 p-4 bg-purple-50 rounded-lg flex items-center justify-between">
                        <div class="flex items-center">
                            <div class="w-10 h-10 bg-purple-100 rounded-lg flex items-center justify-center">
                                <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                                    </path>
                                </svg>
                            </div>
                            <div class="ml-3">
                                <p class="font-medium text-gray-900" id="fileName">document.pdf</p>
                                <p class="text-sm text-gray-600" id="fileSize">2.4 MB</p>
                            </div>
                        </div>
                        <button type="button" id="removeFile" class="text-red-600 hover:text-red-700">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Submit Button -->
                <button type="submit" id="submitBtn"
                    class="w-full py-4 px-6 btn-gradient text-white font-medium rounded-xl transition-all flex items-center justify-center text-lg">
                    <span id="btnText">Tạo Quiz</span>
                    <svg id="btnSpinner" class="hidden w-6 h-6 ml-2 animate-spin" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4">
                        </circle>
                        <path class="opacity-75" fill="currentColor"
                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                        </path>
                    </svg>
                </button>
            </form>
        </div>

        <!-- Tips -->
        <div class="mt-8 bg-blue-50 rounded-xl p-6">
            <h3 class="font-medium text-blue-900 flex items-center">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                Mẹo để có kết quả tốt nhất
            </h3>
            <ul class="mt-3 text-sm text-blue-800 space-y-2">
                <li>• Tài liệu nên có định dạng câu hỏi rõ ràng (đánh số hoặc gạch đầu dòng)</li>
                <li>• Đáp án đúng có thể được đánh dấu bằng màu đỏ hoặc highlight</li>
                <li>• Mỗi câu hỏi nên có từ 2-5 lựa chọn đáp án</li>
                <li>• Hệ thống sử dụng AI để nhận diện đáp án nếu không có đánh dấu rõ ràng</li>
            </ul>
        </div>
    </div>
</div>

<script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    let selectedFile = null;

    // Click to select file
    dropZone.addEventListener('click', () => fileInput.click());

    // Drag and drop handlers
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('border-purple-500', 'bg-purple-50');
    });

    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('border-purple-500', 'bg-purple-50');
    });

    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('border-purple-500', 'bg-purple-50');

        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleFile(files[0]);
        }
    });

    fileInput.addEventListener('change', () => {
        if (fileInput.files.length > 0) {
            handleFile(fileInput.files[0]);
        }
    });

    function handleFile(file) {
        const allowedTypes = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];

        if (!allowedTypes.includes(file.type)) {
            alert('Chỉ hỗ trợ file PDF và DOCX');
            return;
        }

        if (file.size > 50 * 1024 * 1024) {
            alert('File không được vượt quá 50MB');
            return;
        }

        selectedFile = file;
        document.getElementById('fileName').textContent = file.name;
        document.getElementById('fileSize').textContent = formatFileSize(file.size);

        dropZone.classList.add('hidden');
        fileInfo.classList.remove('hidden');
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    document.getElementById('removeFile').addEventListener('click', () => {
        selectedFile = null;
        fileInput.value = '';
        dropZone.classList.remove('hidden');
        fileInfo.classList.add('hidden');
    });

    // Form submission
    document.getElementById('uploadForm').addEventListener('submit', async function (e) {
        e.preventDefault();

        if (!window.authManager || !window.authManager.getAccessToken()) {
            window.location.href = '/login';
            return;
        }

        if (!selectedFile) {
            alert('Vui lòng chọn file');
            return;
        }

        const btn = document.getElementById('submitBtn');
        const btnText = document.getElementById('btnText');
        const btnSpinner = document.getElementById('btnSpinner');

        btn.disabled = true;
        btnText.textContent = 'Đang tải lên...';
        btnSpinner.classList.remove('hidden');

        const formData = new FormData();
        formData.append('file', selectedFile);
        formData.append('title', document.getElementById('title').value);

        try {
            const token = window.authManager.getAccessToken();
            const response = await fetch('/api/v1/quizzes/upload', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` },
                body: formData
            });

            const data = await response.json();

            if (response.status === 401) {
                await window.authManager.silentRefresh();
                // Retry with new token
                const newToken = window.authManager.getAccessToken();
                const retryResponse = await fetch('/api/v1/quizzes/upload', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${newToken}` },
                    body: formData
                });
                const retryData = await retryResponse.json();
                if (retryResponse.ok) {
                    window.location.href = `/quiz/${retryData.quizId}/status`;
                } else {
                    alert(retryData.error || 'Upload thất bại');
                }
                return;
            }

            if (response.ok) {
                // Check for duplicate redirect
                if (data.isDuplicate) {
                    alert(data.message);
                    window.location.href = `/quiz/${data.existingQuizId}`;
                    return;
                }
                window.location.href = `/quiz/${data.quizId}/status`;
            } else {
                alert(data.error || 'Upload thất bại');
            }
        } catch (error) {
            console.error('Upload error:', error);
            alert('Có lỗi xảy ra. Vui lòng thử lại.');
        } finally {
            btn.disabled = false;
            btnText.textContent = 'Tạo Quiz';
            btnSpinner.classList.add('hidden');
        }
    });
</script>
</file>

<file path="backend/src/workers/quiz.worker.ts">
/**
 * Quiz Worker
 * BullMQ worker for background document processing and AI answer detection.
 * Uses 5-layer AI fallback with semantic caching.
 */
import { Queue, Worker, Job } from "bullmq";
import { QuizProcessingJob, ParsedQuestion, ParsedChoice } from "../types/quiz.types";
import { QuestionInput } from "../types/ai.types";
import Quiz, { AnswerSource, QuizStatus } from "../models/quiz.model";
import { driveStorage } from "../utils/storage/drive.storage";
import { documentService } from "../services/document.service";
import { aiOrchestrator } from "../services/ai/aiOrchestrator.service";
import { logger } from "../utils/logger.util";
import path from "path";
import fs from "fs/promises";
import { existsSync } from "fs";
import os from "os";

const QUEUE_NAME = "quiz-processing";

// Queue instance
let quizQueue: Queue | null = null;

/**
 * Get or create quiz processing queue
 */
export function getQuizQueue(): Queue {
    if (!quizQueue) {
        quizQueue = new Queue(QUEUE_NAME, {
            connection: {
                host: process.env.REDIS_HOST || "localhost",
                port: parseInt(process.env.REDIS_PORT || "6379"),
            },
        });
    }
    return quizQueue;
}

/**
 * Add a quiz processing job to the queue
 */
export async function addQuizProcessingJob(job: QuizProcessingJob): Promise<string> {
    const queue = getQuizQueue();
    const added = await queue.add("process-quiz", job, {
        // Auto-retry for graceful postponement
        attempts: 3,
        backoff: {
            type: "fixed",
            delay: 5 * 60 * 1000, // 5 minutes between retries
        },
        removeOnComplete: true,
        removeOnFail: false,
    });

    logger.info(`[QuizWorker] Added job ${added.id} for quiz ${job.quizId}`);
    return added.id || "";
}

async function processQuizDocument(job: Job): Promise<void> {
    const { quizId, documentUrl, documentType } = job.data;
    try {
        await Quiz.findByIdAndUpdate(quizId, { status: QuizStatus.Processing });

        // 1. Parse document using generic parser (supports pdf, docx, doc, txt, rtf, odt)
        const tempPath = documentUrl.replace("file://", "");
        let parsedDoc: any = await documentService.parseGenericDocument(tempPath);

        // 2. Prepare questions for AI orchestrator
        const questionsForAI: QuestionInput[] = parsedDoc.questions.map(function (q: ParsedQuestion, idx: number) {
            return {
                index: idx + 1,
                stem: q.stem,
                choices: q.choices.map(function (c: ParsedChoice) { return { key: c.key, text: c.text }; }),
                section: q.section || ""
            };
        });

        logger.info(`[QuizWorker] Dispatching ${questionsForAI.length} questions to AI Orchestrator`);

        // 3. Call AI Orchestrator (5-layer fallback with caching)
        const aiResult = await aiOrchestrator.solveQuestions(questionsForAI);

        logger.info(`[QuizWorker] AI Result: ${aiResult.cacheHits} cache hits, ${aiResult.cacheMisses} AI calls, ${aiResult.failedQuestions} failed`);

        // Helper to normalize section labels and extract MAJOR section only
        // CLO1.1, CLO1.2, CLO1.3 -> CLO 1
        // Chương 2.1, Chương 2.2 -> Chương 2
        function sanitizeSection(raw: string): string {
            let s = raw.trim().toUpperCase();

            // 1. Fix duplicate words: CLCLO -> CLO, CLO CLO -> CLO
            s = s.replace(/^(CL)+CLO/i, "CLO");
            s = s.replace(/^CLO\s+CLO/i, "CLO");

            // 2. Extract MAJOR section only (Letters + First Number)
            // Examples: "CLO 1.1.2" -> "CLO 1", "CLO1.2" -> "CLO 1", "Chương 2.3" -> "CHƯƠNG 2"
            const majorMatch = s.match(/^([A-ZÀ-Ỹ]+\s*\d+)/i);
            if (majorMatch) {
                s = majorMatch[1];
            }

            // 3. Normalize spacing: "CLO1" -> "CLO 1", "CHƯƠNG2" -> "CHƯƠNG 2"
            s = s.replace(/^([A-ZÀ-Ỹ]+)(\d+)$/i, "$1 $2");

            return s.trim() || "Nội dung chung";
        }

        // 4. Map AI results to final questions (với section đã sanitize)
        // Create a map for quick lookup of AI responses by index
        const aiResponseMap = new Map(aiResult.responses.map(function (r) { return [r.index, r]; }));

        // Track missed questions for validation
        let missedCount = 0;

        const finalQuestions = parsedDoc.questions.map(function (q: ParsedQuestion, idx: number) {
            const sanitizedSection = sanitizeSection(q.section || "");
            // ANCHOR: Always use parser index as source of truth
            const parserIndex = idx + 1;
            const aiResponse = aiResponseMap.get(parserIndex);

            // Check if Visual Mark already detected correct answer (DOCX with bold/highlight)
            const hasVisualMark = q.correctAnswerKey && q.correctAnswerKey.length > 0;

            // Validation: log warning if AI missed this question
            if (!aiResponse && !hasVisualMark) {
                missedCount++;
                logger.warn(`[QuizWorker] AI missed question ${parserIndex}: "${q.stem.substring(0, 50)}..."`);
            }

            return {
                stem: q.stem,
                choices: q.choices,
                // Priority: Visual Mark > AI > Fallback "A"
                correctAnswerKey: hasVisualMark
                    ? q.correctAnswerKey
                    : (aiResponse?.correctKey?.toUpperCase() || "A"),
                explanation: aiResponse?.explanation || "",
                source: hasVisualMark
                    ? AnswerSource.StyleDetected
                    : (aiResponse ? AnswerSource.AI_Generated : AnswerSource.AI_Generated),
                section: sanitizedSection
            };
        });

        if (missedCount > 0) {
            logger.warn(`[QuizWorker] Total ${missedCount} questions missed by AI, using fallback "A"`);
        }

        // Memory cleanup: Free large objects immediately
        parsedDoc = null;
        if (typeof (global as any).gc === "function") {
            (global as any).gc();
            logger.info(`[QuizWorker] Memory cleanup done for Quiz ${quizId}`);
        }

        // DEBUG: Log first 3 questions with their sections
        logger.info(`[QuizWorker] DEBUG - First 3 questions sections:`,
            finalQuestions.slice(0, 3).map(function (q: any) { return { stem: q.stem.substring(0, 30), section: q.section }; })
        );

        // 5. Count questions per section
        const tempCounts: Record<string, number> = {};
        finalQuestions.forEach(function (q: any) {
            tempCounts[q.section] = (tempCounts[q.section] || 0) + 1;
        });

        // Convert to array format (to avoid MongoDB dot-key issues)
        const sections = Object.keys(tempCounts);
        const sectionCounts = sections.map(function (name) {
            return { name, count: tempCounts[name] };
        });

        logger.info(`[QuizWorker] DEBUG - Sections to save: ${JSON.stringify(sections)}`);
        logger.info(`[QuizWorker] DEBUG - SectionCounts: ${JSON.stringify(sectionCounts)}`);

        // Use findById + save instead of findByIdAndUpdate to ensure subdocuments are properly saved
        const quiz = await Quiz.findById(quizId);
        if (quiz) {
            quiz.questions = finalQuestions as any;
            quiz.totalQuestions = finalQuestions.length;
            quiz.processedQuestions = finalQuestions.length;
            quiz.sections = sections;
            quiz.sectionCounts = sectionCounts;
            quiz.status = QuizStatus.Completed;
            await quiz.save();

            // 6. Upload to Google Drive (optional - if credentials configured)
            if (process.env.GOOGLE_DRIVE_CLIENT_EMAIL && process.env.GOOGLE_DRIVE_FOLDER_ID) {
                try {
                    const fileName = path.basename(tempPath);
                    const mimeType = documentType === "docx"
                        ? "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                        : "application/pdf";

                    const { webViewLink } = await driveStorage.uploadFile(tempPath, fileName, mimeType);

                    // Update quiz with Drive URL
                    quiz.documentUrl = webViewLink;
                    await quiz.save();

                    // Delete local file after successful upload
                    if (existsSync(tempPath)) {
                        await fs.unlink(tempPath).catch(() => { });
                        logger.info(`[QuizWorker] Uploaded to Drive & deleted local: ${fileName}`);
                    }
                } catch (driveError: any) {
                    logger.warn(`[QuizWorker] Drive upload failed (keeping local): ${driveError.message}`);
                }
            }
        }

        logger.info(`[QuizWorker] Completed quiz ${quizId} with ${sections.length} sections.`);

    } catch (error: any) {
        const errorMsg = error?.message || String(error);
        logger.error(`[QuizWorker] Worker failed: ${errorMsg}`);

        // Delete quiz record and uploaded file to keep server clean
        try {
            const tempPath = documentUrl.replace("file://", "");
            if (existsSync(tempPath)) {
                await fs.unlink(tempPath).catch(() => { });
                logger.info(`[QuizWorker] Deleted file: ${tempPath}`);
            }
            await Quiz.findByIdAndDelete(quizId);
            logger.info(`[QuizWorker] Deleted failed quiz: ${quizId}`);
        } catch (cleanupError) {
            logger.error(`[QuizWorker] Cleanup failed:`, cleanupError);
        }
    }
}

/**
 * Start the quiz processing worker
 */
export function startQuizWorker(): Worker {
    // Use concurrency 1 to avoid hitting Gemini rate limits
    const concurrency = parseInt(process.env.BULLMQ_QUIZ_CONCURRENCY || "1");

    const worker = new Worker(QUEUE_NAME, processQuizDocument, {
        connection: {
            host: process.env.REDIS_HOST || "localhost",
            port: parseInt(process.env.REDIS_PORT || "6379"),
        },
        concurrency,
        limiter: {
            max: 5,
            duration: 60000, // 5 jobs per minute max
        },
        autorun: true,
    });

    worker.on("completed", function (job: Job) {
        logger.info(`[QuizWorker] Job ${job.id} completed`);
    });

    worker.on("failed", function (job: Job | undefined, error: Error) {
        logger.error(`[QuizWorker] Job ${job?.id} failed:`, error);
    });

    logger.info(`[QuizWorker] Started with concurrency ${concurrency}`);

    return worker;
}
</file>

<file path="backend/test-parser.js">
const fs = require('fs');
const pdfParse = require('pdf-parse');

async function test() {
    const dataBuffer = fs.readFileSync('uploads/documents/1766418852477-ziguix-CAU HOI ON TAP IoT.pdf');
    const data = await pdfParse(dataBuffer);

    const rawText = data.text;
    const fullText = rawText.split(/\r?\n/).map(l => l.trim()).filter(l => l).join(' ');

    // Better regex - look for A./B./C./D. with any text until next choice
    const choiceRegex = /([A-D])[\.\)]\s*(.+?)(?=\s+[A-D][\.\)]|$)/gi;
    const matches = [...fullText.matchAll(choiceRegex)];

    console.log('Total choice matches:', matches.length);

    // Count
    const counts = { A: 0, B: 0, C: 0, D: 0 };
    matches.forEach(m => {
        const key = m[1].toUpperCase();
        if (counts[key] !== undefined) counts[key]++;
    });
    console.log('Choice counts:', counts);

    console.log('\nSample sequence (first 12):');
    matches.slice(0, 12).forEach((m, i) => {
        console.log(m[1].toUpperCase(), ':', m[2].substring(0, 50).replace(/\n/g, ' '));
    });
}

test().catch(e => console.error('Error:', e));
</file>

<file path="backend/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "lib": [
            "ES2020"
        ],
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true,
        "baseUrl": ".",
        "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist"
    ]
}
</file>

</files>
